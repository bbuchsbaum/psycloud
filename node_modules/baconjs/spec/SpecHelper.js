// Generated by CoffeeScript 1.6.3
(function() {
  var Bacon, browser, expect, grep, hasValue, justValues, lastNonError, match, origDescribe, seqs, t, toValue, toValues, verifyCleanup, verifyExhausted, verifyFinalState, verifySingleSubscriber, verifyStreamWith, verifySwitching, verifySwitchingAggressively, verifySwitchingWithUnsub, waitMs, _;

  expect = require("chai").expect;

  Bacon = (require("../src/Bacon")).Bacon;

  _ = Bacon._;

  t = this.t = function(time) {
    return time;
  };

  seqs = [];

  waitMs = 100;

  browser = typeof window === "object";

  if (browser) {
    console.log("Running in browser, narrowing test set");
  }

  grep = process.env.grep;

  if (grep) {
    console.log("running with grep:", grep);
    origDescribe = describe;
    match = false;
    global.describe = function(desc, f) {
      if (desc.indexOf(grep) >= 0) {
        match = true;
        origDescribe(desc, f);
        return match = false;
      } else if (match) {
        return origDescribe(desc, f);
      }
    };
  }

  this.error = function(msg) {
    return new Bacon.Error(msg);
  };

  this.soon = function(f) {
    return setTimeout(f, t(1));
  };

  this.series = function(interval, values) {
    return Bacon.sequentially(t(interval), values);
  };

  this.repeat = function(interval, values) {
    var source;
    source = Bacon.repeatedly(t(interval), values);
    seqs.push({
      values: values,
      source: source
    });
    return source;
  };

  this.atGivenTimes = function(timesAndValues) {
    var streams, tv;
    streams = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = timesAndValues.length; _i < _len; _i++) {
        tv = timesAndValues[_i];
        _results.push(Bacon.later(t(tv[0]), tv[1]));
      }
      return _results;
    })();
    return Bacon.mergeAll(streams);
  };

  this.expectStreamTimings = function(src, expectedEventsAndTimings, options) {
    var srcWithRelativeTime;
    srcWithRelativeTime = function() {
      var now, relativeTime, t0, withRelativeTime;
      now = Bacon.scheduler.now;
      t0 = now();
      relativeTime = function() {
        return Math.floor(now() - t0);
      };
      withRelativeTime = function(x) {
        return [relativeTime(), x];
      };
      return src().map(withRelativeTime);
    };
    return this.expectStreamEvents(srcWithRelativeTime, expectedEventsAndTimings, options);
  };

  this.expectStreamEvents = function(src, expectedEvents, _arg) {
    var unstable;
    unstable = (_arg != null ? _arg : {
      unstable: false
    }).unstable;
    verifySingleSubscriber(src, expectedEvents);
    if (!browser) {
      verifySwitching(src, expectedEvents);
    }
    if (!browser) {
      verifySwitchingWithUnsub(src, expectedEvents);
    }
    if (!unstable) {
      return verifySwitchingAggressively(src, expectedEvents);
    }
  };

  this.expectPropertyEvents = function(src, expectedEvents) {
    var events, events2, property, streamEnded;
    expect(expectedEvents.length > 0).to.deep.equal(true);
    property = null;
    events = [];
    events2 = [];
    streamEnded = function() {
      return ended;
    };
    before(function() {
      return property = src();
    });
    before(function(done) {
      return property.subscribe(function(event) {
        if (event.isEnd()) {
          return done();
        } else {
          events.push(toValue(event));
          if (event.hasValue()) {
            return property.subscribe(function(event) {
              if (event.isInitial()) {
                events2.push(event.value());
              }
              return Bacon.noMore;
            });
          }
        }
      });
    });
    it("is a Property", function() {
      return expect(property instanceof Bacon.Property).to.deep.equal(true);
    });
    it("outputs expected events in order", function() {
      return expect(events).to.deep.equal(toValues(expectedEvents));
    });
    it("outputs expected events in order when subscribing after each value", function() {
      return expect(events2).to.deep.equal(justValues(expectedEvents));
    });
    it("has correct final state", function() {
      return verifyFinalState(property, lastNonError(expectedEvents));
    });
    return it("cleans up observers", verifyCleanup);
  };

  verifySingleSubscriber = function(srcF, expectedEvents) {
    return verifyStreamWith("(single subscriber)", srcF, expectedEvents, function(src, events, done) {
      return src.subscribe(function(event) {
        if (event.isEnd()) {
          return done();
        } else {
          expect(event instanceof Bacon.Initial).to.deep.equal(false);
          return events.push(toValue(event));
        }
      });
    });
  };

  verifySwitching = function(srcF, expectedEvents, done) {
    return verifyStreamWith("(switching subscribers)", srcF, expectedEvents, function(src, events, done) {
      var newSink;
      newSink = function() {
        return function(event) {
          if (event.isEnd()) {
            return done();
          } else {
            expect(event instanceof Bacon.Initial).to.deep.equal(false);
            events.push(toValue(event));
            src.subscribe(newSink());
            return Bacon.noMore;
          }
        };
      };
      return src.subscribe(newSink());
    });
  };

  verifySwitchingWithUnsub = function(srcF, expectedEvents, done) {
    return verifyStreamWith("(switching subscribers with unsub)", srcF, expectedEvents, function(src, events, done) {
      var globalEnded, subNext;
      globalEnded = false;
      subNext = function() {
        var newSink, unsub;
        unsub = null;
        newSink = function() {
          var ended, noMoreExpected, usedUnsub;
          ended = false;
          noMoreExpected = false;
          usedUnsub = false;
          return function(event) {
            var prevUnsub;
            if (noMoreExpected) {
              console.log("got unexp", event.describe(), "usedUnsub", usedUnsub);
            }
            if (event.isEnd()) {
              if (ended) {
                console.log("one stream, two ends");
              } else if (globalEnded) {
                console.log("two ends");
              }
              globalEnded = true;
              ended = true;
              return done();
            } else {
              expect(event instanceof Bacon.Initial).to.deep.equal(false);
              events.push(toValue(event));
              prevUnsub = unsub;
              noMoreExpected = true;
              subNext();
              if (unsub != null) {
                usedUnsub = true;
                return unsub();
              } else {
                return Bacon.noMore;
              }
            }
          };
        };
        return unsub = src.subscribe(newSink());
      };
      return subNext();
    });
  };

  verifyStreamWith = function(description, srcF, expectedEvents, collectF) {
    return describe(description, function() {
      var events, src;
      src = null;
      events = [];
      before(function() {
        src = srcF();
        return expect(src instanceof Bacon.EventStream).to.equal(true);
      });
      before(function(done) {
        return collectF(src, events, done);
      });
      it("outputs expected value in order", function() {
        return expect(events).to.deep.equal(toValues(expectedEvents));
      });
      it("the stream is exhausted", function() {
        return verifyExhausted(src);
      });
      return it("cleans up observers", verifyCleanup);
    });
  };

  verifySwitchingAggressively = function(srcF, expectedEvents, done) {
    return describe("(switching aggressively)", function() {
      var events, src;
      src = null;
      events = [];
      before(function() {
        src = srcF();
        return expect(src instanceof Bacon.EventStream).to.equal(true);
      });
      before(function(done) {
        var newSink, unsub;
        newSink = function() {
          var unsub;
          unsub = null;
          return function(event) {
            if (event.isEnd()) {
              return done();
            } else {
              expect(event instanceof Bacon.Initial).to.deep.equal(false);
              events.push(toValue(event));
              if (unsub != null) {
                unsub();
              }
              unsub = src.subscribe(newSink());
              return Bacon.noMore;
            }
          };
        };
        return unsub = src.subscribe(newSink());
      });
      it("outputs expected value in order", function() {
        return expect(events).to.deep.equal(toValues(expectedEvents));
      });
      it("the stream is exhausted", function() {
        return verifyExhausted(src);
      });
      return it("cleans up observers", verifyCleanup);
    });
  };

  verifyExhausted = function(src) {
    var events;
    events = [];
    src.subscribe(function(event) {
      return events.push(event);
    });
    return expect(events[0].isEnd()).to.deep.equal(true);
  };

  lastNonError = function(events) {
    return _.last(_.filter((function(e) {
      return toValue(e) !== "<error>";
    }), events));
  };

  verifyFinalState = function(property, value) {
    var events;
    events = [];
    property.subscribe(function(event) {
      return events.push(event);
    });
    return expect(toValues(events)).to.deep.equal(toValues([value, "<end>"]));
  };

  verifyCleanup = this.verifyCleanup = function() {
    var seq, _i, _len;
    for (_i = 0, _len = seqs.length; _i < _len; _i++) {
      seq = seqs[_i];
      expect(seq.source.hasSubscribers()).to.deep.equal(false);
    }
    return seqs = [];
  };

  toValues = function(xs) {
    var values, x, _i, _len;
    values = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      values.push(toValue(x));
    }
    return values;
  };

  toValue = function(x) {
    switch (true) {
      case !(x != null ? typeof x.isEvent === "function" ? x.isEvent() : void 0 : void 0):
        return x;
      case x.isError():
        return "<error>";
      case x.isEnd():
        return "<end>";
      default:
        return x.value();
    }
  };

  justValues = function(xs) {
    return _.filter(hasValue, xs);
  };

  hasValue = function(x) {
    return toValue(x) !== "<error>";
  };

  this.toValues = toValues;

  Bacon.Observable.prototype.onUnsub = function(f) {
    var ended, self;
    self = this;
    ended = false;
    return new Bacon.EventStream(function(sink) {
      var unsub;
      unsub = self.subscribe(sink);
      return function() {
        f();
        return unsub();
      };
    });
  };

}).call(this);
