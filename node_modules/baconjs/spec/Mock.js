// Generated by CoffeeScript 1.6.3
(function() {
  var Mock, eq, expect, mockFunction,
    __slice = [].slice;

  expect = require("chai").expect;

  Mock = (function() {
    function Mock() {
      var methodNames, name, _i, _len,
        _this = this;
      methodNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = methodNames.length; _i < _len; _i++) {
        name = methodNames[_i];
        this[name] = mockFunction(name);
      }
      this.verify = function() {
        var verifier, _j, _len1;
        verifier = {};
        for (_j = 0, _len1 = methodNames.length; _j < _len1; _j++) {
          name = methodNames[_j];
          verifier[name] = _this[name].verify;
        }
        return verifier;
      };
      this.when = function() {
        var assign, returner, _j, _len1;
        returner = {};
        assign = function(name) {
          return returner[name] = function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return {
              thenReturn: function(returnValue) {
                var _ref;
                return (_ref = _this[name].doReturn(returnValue)).when.apply(_ref, args);
              }
            };
          };
        };
        for (_j = 0, _len1 = methodNames.length; _j < _len1; _j++) {
          name = methodNames[_j];
          assign(name);
        }
        return returner;
      };
    }

    return Mock;

  })();

  mockFunction = function(name) {
    var calls, method, returns,
      _this = this;
    calls = [];
    returns = [];
    method = function() {
      var args, returnCombo, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      calls.push(args);
      for (_i = 0, _len = returns.length; _i < _len; _i++) {
        returnCombo = returns[_i];
        if (eq(returnCombo.args, args)) {
          return returnCombo.returnValue;
        }
      }
    };
    method.verify = function() {
      var actualCall, args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!calls) {
        throw "not called: " + name;
      }
      actualCall = calls[0];
      calls.splice(0, 1);
      return expect(actualCall).to.deep.equal(args);
    };
    method.doReturn = function(returnValue) {
      return {
        when: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return returns.push({
            args: args,
            returnValue: returnValue
          });
        }
      };
    };
    return method;
  };

  eq = function(xs, ys) {
    var i, x, _i, _len;
    if (xs.length !== ys.length) {
      return false;
    }
    for (i = _i = 0, _len = xs.length; _i < _len; i = ++_i) {
      x = xs[i];
      if (x !== ys[i]) {
        return false;
      }
    }
    return true;
  };

  this.mock = function() {
    var methodNames;
    methodNames = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(Mock, methodNames, function(){});
  };

  this.mockFunction = mockFunction;

}).call(this);
