// Generated by CoffeeScript 1.6.3
(function() {
  var Bacon, EventEmitter, Mocks, TickScheduler, add, endlessly, error, expect, expectPropertyEvents, expectStreamEvents, id, lessThan, mock, mockFunction, repeat, sc, series, soon, t, testLiftedCallback, testSideEffects, th, times, toEventTarget, toValues, unstable, verifyCleanup,
    __slice = [].slice;

  expect = require("chai").expect;

  Bacon = require("../src/Bacon").Bacon;

  Mocks = require("./Mock");

  TickScheduler = require("./TickScheduler").TickScheduler;

  mock = Mocks.mock;

  mockFunction = Mocks.mockFunction;

  EventEmitter = require("events").EventEmitter;

  th = require("./SpecHelper");

  t = th.t;

  expectStreamEvents = th.expectStreamEvents;

  expectPropertyEvents = th.expectPropertyEvents;

  verifyCleanup = th.verifyCleanup;

  error = th.error;

  soon = th.soon;

  series = th.series;

  repeat = th.repeat;

  toValues = th.toValues;

  sc = TickScheduler();

  Bacon.scheduler = sc;

  unstable = {
    unstable: true
  };

  describe("Bacon._", function() {
    var _;
    _ = Bacon._;
    describe("head", function() {
      expect(_.head([5, 2, 9])).to.equal(5);
      expect(_.head([])).to.equal(void 0);
      return expect(_.head(5)).to.equal(void 0);
    });
    describe("always", function() {
      return expect(_.always(5)("francis")).to.equal(5);
    });
    describe("negate", function() {
      return expect(_.negate(_.always(true))("timanttikobra")).to.be["false"];
    });
    describe("empty", function() {
      expect(_.empty([])).to.be["true"];
      expect(_.empty("")).to.be["true"];
      expect(_.empty([1])).to.be["false"];
      return expect(_.empty("1")).to.be["false"];
    });
    describe("tail", function() {
      expect(_.tail([1, 2, 3])).to.deep.equal([2, 3]);
      expect(_.tail([1])).to.deep.equal([]);
      return expect(_.tail([])).to.deep.equal([]);
    });
    describe("filter", function() {
      return expect(_.filter(_.empty, ["", "1", [], [2]])).to.deep.equal(["", []]);
    });
    describe("map", function() {
      return expect(_.map(_.head, [[], [1], [2, 2], [3, 3, 3]])).to.deep.equal([void 0, 1, 2, 3]);
    });
    describe("flatMap", function() {
      return expect(_.flatMap((function(x) {
        return [x, x];
      }), [1, 2, 3])).to.deep.equal([1, 1, 2, 2, 3, 3]);
    });
    describe("each", function() {
      return it("provides key and value to iterator", function() {
        var expectKeyVals;
        expectKeyVals = function(x, expectedKeys, expectedValues) {
          var keys, values;
          keys = [];
          values = [];
          _.each(x, function(key, value) {
            keys.push(key);
            return values.push(value);
          });
          return expect([keys, values]).to.deep.equal([expectedKeys, expectedValues]);
        };
        expectKeyVals({
          cat: "furry",
          bird: "feathery"
        }, ["cat", "bird"], ["furry", "feathery"]);
        return expectKeyVals([1, 2, 3], ["0", "1", "2"], [1, 2, 3]);
      });
    });
    describe("toArray", function() {
      expect(_.toArray(2)).to.deep.equal([2]);
      it("ignores rest of arguments", function() {
        return expect(_.toArray(1, 1, 2)).to.deep.equal([1]);
      });
      return it("should, when given an array, return it back (not a copy)", function() {
        var arr;
        arr = [];
        return expect(_.toArray(arr)).to.equal(arr);
      });
    });
    describe("contains", function() {
      expect(_.contains("abc", "c")).to.be["true"];
      expect(_.contains("abc", "x")).to.be["false"];
      expect(_.contains([2, 4, 6], 4)).to.be["true"];
      return expect(_.contains([2, 4, 6], 3)).to.be["false"];
    });
    describe("id", function() {
      var obj;
      obj = {};
      return expect(_.id(obj)).to.equal(obj);
    });
    describe("last", function() {
      expect(_.last([2, 4])).to.equal(4);
      return expect(_.last("last")).to.equal("t");
    });
    describe("all", function() {
      expect(_.all([[false, true], [true, true]], _.head)).to.be["false"];
      expect(_.all([[true, false], [true, true]], _.head)).to.be["true"];
      return it("should test truthiness if no function given", function() {
        expect(_.all([true, false, true])).to.be["false"];
        expect(_.all([true, true, true])).to.be["true"];
        return expect(_.all([1, true, 1])).to.be["true"];
      });
    });
    describe("any", function() {
      expect(_.any([[false, true], [true, true]], _.head)).to.be["true"];
      expect(_.any([[false, false], [false, true]], _.head)).to.be["false"];
      return it("should test truthiness if no function given", function() {
        expect(_.any([false, false, false])).to.be["false"];
        return expect(_.any([true, false, true])).to.be["true"];
      });
    });
    describe("without", function() {
      return expect(_.without("apple", ["bacon", "apple", "apple", "omelette"])).to.deep.equal(["bacon", "omelette"]);
    });
    describe("remove", function() {
      expect(_.remove("apple", ["bacon", "apple", "apple", "omelette"])).to.deep.equal(["apple"]);
      return expect(_.remove("raisin", ["bacon", "apple", "apple", "omelette"])).to.deep.equal(void 0);
    });
    describe("fold", function() {
      return expect(_.fold([1, 2, 3, 4, 5], 0, function(s, n) {
        return s + n;
      })).to.equal(15);
    });
    return describe("toString", function() {
      it("for objects", function() {
        return expect(_.toString({
          a: "b"
        })).to.equal("{a:b}");
      });
      return it("for circular refs", function() {
        var obj;
        obj = {
          name: "nasty"
        };
        obj.self = obj;
        return expect(_.toString(obj).length).to.be.below(100);
      });
    });
  });

  describe("Bacon.later", function() {
    describe("should send single event and end", function() {
      return expectStreamEvents(function() {
        return Bacon.later(t(1), "lol");
      }, ["lol"]);
    });
    describe("supports sending an Error event as well", function() {
      return expectStreamEvents(function() {
        return Bacon.later(t(1), new Bacon.Error("oops"));
      }, [error()]);
    });
    it("toString", function() {
      return expect(Bacon.later(1, "wat").toString()).to.equal("Bacon.later(1,wat)");
    });
    return it("inspect", function() {
      return expect(Bacon.later(1, "wat").inspect()).to.equal("Bacon.later(1,wat)");
    });
  });

  describe("Bacon.sequentially", function() {
    describe("should send given events and end", function() {
      return expectStreamEvents(function() {
        return Bacon.sequentially(t(1), ["lol", "wut"]);
      }, ["lol", "wut"]);
    });
    describe("include error events", function() {
      return expectStreamEvents(function() {
        return Bacon.sequentially(t(1), [error(), "lol"]);
      }, [error(), "lol"]);
    });
    describe("will stop properly even when exception thrown by subscriber", function() {
      return expectStreamEvents(function() {
        var s;
        s = Bacon.sequentially(t(1), ["lol", "wut"]);
        s.onValue(function(value) {
          throw "testing";
        });
        return s;
      }, []);
    });
    return it("toString", function() {
      return expect(Bacon.sequentially(1, [2]).toString()).to.equal("Bacon.sequentially(1,[2])");
    });
  });

  describe("Bacon.repeatedly", function() {
    describe("repeats given sequence forever", function() {
      return expectStreamEvents(function() {
        return Bacon.repeatedly(1, [1, 2]).take(5);
      }, [1, 2, 1, 2, 1]);
    });
    return it("toString", function() {
      return expect(Bacon.repeatedly(1, [1]).toString()).to.equal("Bacon.repeatedly(1,[1])");
    });
  });

  describe("Bacon.interval", function() {
    describe("repeats single element indefinitely", function() {
      return expectStreamEvents(function() {
        return Bacon.interval(t(1), "x").take(3);
      }, ["x", "x", "x"]);
    });
    return it("toString", function() {
      return expect(Bacon.interval(1, 2).toString()).to.equal("Bacon.interval(1,2)");
    });
  });

  describe("Bacon.fromPoll", function() {
    describe("repeatedly polls given function for values", function() {
      return expectStreamEvents(function() {
        return Bacon.fromPoll(1, (function() {
          return "lol";
        })).take(2);
      }, ["lol", "lol"]);
    });
    return it("toString", function() {
      return expect(Bacon.fromPoll(1, (function() {})).toString()).to.equal("Bacon.fromPoll(1,function)");
    });
  });

  testLiftedCallback = function(src, liftedCallback) {
    var input, output;
    input = [Bacon.constant('a'), 'x', Bacon.constant('b').toProperty(), 'y'];
    output = ['a', 'x', 'b', 'y'];
    return expectStreamEvents(function() {
      return liftedCallback.apply(null, [src].concat(__slice.call(input)));
    }, [output]);
  };

  describe("Bacon.fromCallback", function() {
    describe("makes an EventStream from function that takes a callback", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = function(callback) {
          return callback("lol");
        };
        return stream = Bacon.fromCallback(src);
      }, ["lol"]);
    });
    describe("supports partial application", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = function(param, callback) {
          return callback(param);
        };
        return stream = Bacon.fromCallback(src, "lol");
      }, ["lol"]);
    });
    describe("supports partial application with Observable arguments", function() {
      return testLiftedCallback(function() {
        var callback, values, _i;
        values = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        return callback(values);
      }, Bacon.fromCallback);
    });
    describe("supports object, methodName, partial application", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = {
          "go": function(param, callback) {
            return callback(param + " " + this.name);
          },
          "name": "bob"
        };
        return stream = Bacon.fromCallback(src, "go", "hello");
      }, ["hello bob"]);
    });
    return it("toString", function() {
      return expect(Bacon.fromCallback((function() {}), "lol").toString()).to.equal("Bacon.fromCallback(function,lol)");
    });
  });

  describe("Bacon.fromNodeCallback", function() {
    describe("makes an EventStream from function that takes a node-style callback", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = function(callback) {
          return callback(null, "lol");
        };
        return stream = Bacon.fromNodeCallback(src);
      }, ["lol"]);
    });
    describe("handles error parameter correctly", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = function(callback) {
          return callback('errortxt', null);
        };
        return stream = Bacon.fromNodeCallback(src);
      }, [error()]);
    });
    describe("supports partial application", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = function(param, callback) {
          return callback(null, param);
        };
        return stream = Bacon.fromNodeCallback(src, "lol");
      }, ["lol"]);
    });
    describe("supports partial application with Observable arguments", function() {
      return testLiftedCallback(function() {
        var callback, values, _i;
        values = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
        return callback(null, values);
      }, Bacon.fromNodeCallback);
    });
    describe("supports object, methodName, partial application", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = {
          "go": function(param, callback) {
            return callback(null, param + " " + this.name);
          },
          "name": "bob"
        };
        return stream = Bacon.fromNodeCallback(src, "go", "hello");
      }, ["hello bob"]);
    });
    return it("toString", function() {
      return expect(Bacon.fromNodeCallback((function() {}), "lol").toString()).to.equal("Bacon.fromNodeCallback(function,lol)");
    });
  });

  toEventTarget = function(emitter) {
    return {
      addEventListener: function(event, handler) {
        return emitter.addListener(event, handler);
      },
      removeEventListener: function(event, handler) {
        return emitter.removeListener(event, handler);
      }
    };
  };

  describe("Bacon.fromEventTarget", function() {
    soon = function(f) {
      return setTimeout(f, 0);
    };
    describe("should create EventStream from DOM object", function() {
      return expectStreamEvents(function() {
        var element, emitter;
        emitter = new EventEmitter();
        emitter.on("newListener", function() {
          return soon(function() {
            return emitter.emit("click", "x");
          });
        });
        element = toEventTarget(emitter);
        return Bacon.fromEventTarget(element, "click").take(1);
      }, ["x"]);
    });
    describe("should create EventStream from EventEmitter", function() {
      return expectStreamEvents(function() {
        var emitter;
        emitter = new EventEmitter();
        emitter.on("newListener", function() {
          return soon(function() {
            return emitter.emit("data", "x");
          });
        });
        return Bacon.fromEventTarget(emitter, "data").take(1);
      }, ["x"]);
    });
    describe("should allow a custom map function for EventStream from EventEmitter", function() {
      return expectStreamEvents(function() {
        var emitter,
          _this = this;
        emitter = new EventEmitter();
        emitter.on("newListener", function() {
          return soon(function() {
            return emitter.emit("data", "x", "y");
          });
        });
        return Bacon.fromEventTarget(emitter, "data", function(x, y) {
          return [x, y];
        }).take(1);
      }, [["x", "y"]]);
    });
    it("should clean up event listeners from EventEmitter", function() {
      var emitter;
      emitter = new EventEmitter();
      Bacon.fromEventTarget(emitter, "data").take(1).subscribe(function() {});
      emitter.emit("data", "x");
      return expect(emitter.listeners("data").length).to.deep.equal(0);
    });
    it("should clean up event listeners from DOM object", function() {
      var dispose, element, emitter;
      emitter = new EventEmitter();
      element = toEventTarget(emitter);
      dispose = Bacon.fromEventTarget(element, "click").subscribe(function() {});
      dispose();
      return expect(emitter.listeners("click").length).to.deep.equal(0);
    });
    return it("toString", function() {
      return expect(Bacon.fromEventTarget({}, "click").toString()).to.equal("Bacon.fromEventTarget({},click)");
    });
  });

  describe("Observable.log", function() {
    var preservingLog;
    preservingLog = function(f) {
      var originalConsole, originalLog;
      originalConsole = console;
      originalLog = console.log;
      try {
        return f();
      } finally {
        global.console = originalConsole;
        console.log = originalLog;
      }
    };
    it("does not crash", function() {
      return preservingLog(function() {
        console.log = function() {};
        return Bacon.constant(1).log();
      });
    });
    it("does not crash in case console.log is not defined", function() {
      return preservingLog(function() {
        console.log = void 0;
        return Bacon.constant(1).log();
      });
    });
    return it("toString", function() {
      return expect(Bacon.never().log().toString()).to.equal("Bacon.never()");
    });
  });

  describe("Observable.slidingWindow", function() {
    describe("slides the window for EventStreams", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).slidingWindow(2);
      }, [[], [1], [1, 2], [2, 3]]);
    });
    describe("slides the window for Properties", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).toProperty().slidingWindow(2);
      }, [[], [1], [1, 2], [2, 3]]);
    });
    describe("accepts second parameter for minimum amount of values", function() {
      expectPropertyEvents(function() {
        return series(1, [1, 2, 3, 4]).slidingWindow(3, 2);
      }, [[1, 2], [1, 2, 3], [2, 3, 4]]);
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3, 4]).toProperty(0).slidingWindow(3, 2);
      }, [[0, 1], [0, 1, 2], [1, 2, 3], [2, 3, 4]]);
    });
    return it("toString", function() {
      return expect(Bacon.never().slidingWindow(2).toString()).to.equal("Bacon.never().slidingWindow(2,0)");
    });
  });

  describe("EventStream.filter", function() {
    describe("should filter values", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, error(), 3]).filter(lessThan(3));
      }, [1, 2, error()]);
    });
    describe("extracts field values", function() {
      return expectStreamEvents(function() {
        return series(1, [
          {
            good: true,
            value: "yes"
          }, {
            good: false,
            value: "no"
          }
        ]).filter(".good").map(".value");
      }, ["yes"]);
    });
    describe("can filter by Property value", function() {
      return expectStreamEvents(function() {
        var odd, src;
        src = series(1, [1, 1, 2, 3, 4, 4, 8, 7]);
        odd = src.map(function(x) {
          return x % 2;
        }).toProperty();
        return src.filter(odd);
      }, [1, 1, 3, 7]);
    });
    return it("toString", function() {
      return expect(Bacon.never().filter(false).toString()).to.equal("Bacon.never().filter(function)");
    });
  });

  describe("EventStream.map", function() {
    describe("should map with given function", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3]).map(times, 2);
      }, [2, 4, 6]);
    });
    describe("also accepts a constant value", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3]).map("lol");
      }, ["lol", "lol", "lol"]);
    });
    describe("extracts property from value object", function() {
      var o;
      o = {
        lol: "wut"
      };
      return expectStreamEvents(function() {
        return repeat(1, [o]).take(3).map(".lol");
      }, ["wut", "wut", "wut"]);
    });
    describe("extracts a nested property too", function() {
      var o;
      o = {
        lol: {
          wut: "wat"
        }
      };
      return expectStreamEvents(function() {
        return Bacon.once(o).map(".lol.wut");
      }, ["wat"]);
    });
    describe("in case of a function property, calls the function with no args", function() {
      return expectStreamEvents(function() {
        return Bacon.once([1, 2, 3]).map(".length");
      }, [3]);
    });
    describe("allows arguments for methods", function() {
      var thing;
      thing = {
        square: function(x) {
          return x * x;
        }
      };
      return expectStreamEvents(function() {
        return Bacon.once(thing).map(".square", 2);
      }, [4]);
    });
    describe("works with method call on given object, with partial application", function() {
      var multiplier;
      multiplier = {
        multiply: function(x, y) {
          return x * y;
        }
      };
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3]).map(multiplier, "multiply", 2);
      }, [2, 4, 6]);
    });
    describe("can map to a Property value", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3]).map(Bacon.constant(2));
      }, [2, 2, 2]);
    });
    it("preserves laziness", function() {
      var calls, id;
      calls = 0;
      id = function(x) {
        calls++;
        return x;
      };
      Bacon.fromArray([1, 2, 3, 4, 5]).map(id).skip(4).onValue();
      return expect(calls).to.equal(1);
    });
    return it("toString", function() {
      return expect(Bacon.once(1).map(true).toString()).to.equal("Bacon.once(1).map(function)");
    });
  });

  describe("EventStream.mapError", function() {
    describe("should map error events with given function", function() {
      return expectStreamEvents(function() {
        return repeat(1, [1, error("OOPS")]).mapError(id).take(2);
      }, [1, "OOPS"]);
    });
    describe("also accepts a constant value", function() {
      return expectStreamEvents(function() {
        return repeat(1, [1, error()]).mapError("ERR").take(2);
      }, [1, "ERR"]);
    });
    return it("toString", function() {
      return expect(Bacon.never().mapError(true).toString()).to.equal("Bacon.never().mapError(function)");
    });
  });

  describe("EventStream.doAction", function() {
    it("calls function before sending value to listeners", function() {
      var bus, called, s;
      called = [];
      bus = new Bacon.Bus();
      s = bus.doAction(function(x) {
        return called.push(x);
      });
      s.onValue(function() {});
      s.onValue(function() {});
      bus.push(1);
      return expect(called).to.deep.equal([1]);
    });
    describe("does not alter the stream", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).doAction(function() {});
      }, [1, 2]);
    });
    return it("toString", function() {
      return expect(Bacon.never().doAction((function() {})).toString()).to.equal("Bacon.never().doAction(function)");
    });
  });

  describe("EventStream.mapEnd", function() {
    describe("produces an extra element on stream end", function() {
      return expectStreamEvents(function() {
        return series(1, ["1", error()]).mapEnd("the end");
      }, ["1", error(), "the end"]);
    });
    describe("accepts either a function or a constant value", function() {
      return expectStreamEvents(function() {
        return series(1, ["1", error()]).mapEnd(function() {
          return "the end";
        });
      }, ["1", error(), "the end"]);
    });
    describe("works with undefined value as well", function() {
      return expectStreamEvents(function() {
        return series(1, ["1", error()]).mapEnd();
      }, ["1", error(), void 0]);
    });
    return it("toString", function() {
      return expect(Bacon.never().mapEnd(true).toString()).to.equal("Bacon.never().mapEnd(function)");
    });
  });

  describe("EventStream.take", function() {
    describe("takes N first elements", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3, 4]).take(2);
      }, [1, 2]);
    });
    describe("works with N=0", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3, 4]).take(0);
      }, []);
    });
    describe("will stop properly even when exception thrown by subscriber", function() {
      return expectStreamEvents(function() {
        var s;
        s = Bacon.repeatedly(t(1), ["lol", "wut"]).take(2);
        s.onValue(function(value) {
          throw "testing";
        });
        return s;
      }, []);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3, 4]).take(2);
      }, [1, 2]);
    });
    return it("toString", function() {
      return expect(Bacon.never().take(1).toString()).to.equal("Bacon.never().take(1)");
    });
  });

  describe("EventStream.takeWhile", function() {
    describe("takes while predicate is true", function() {
      return expectStreamEvents(function() {
        return repeat(1, [1, error("wat"), 2, 3]).takeWhile(lessThan(3));
      }, [1, error("wat"), 2]);
    });
    describe("extracts field values", function() {
      return expectStreamEvents(function() {
        return series(1, [
          {
            good: true,
            value: "yes"
          }, {
            good: false,
            value: "no"
          }
        ]).takeWhile(".good").map(".value");
      }, ["yes"]);
    });
    describe("can filter by Property value", function() {
      return expectStreamEvents(function() {
        var odd, src;
        src = series(1, [1, 1, 2, 3, 4, 4, 8, 7]);
        odd = src.map(function(x) {
          return x % 2;
        }).toProperty();
        return src.takeWhile(odd);
      }, [1, 1]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3]).takeWhile(lessThan(3));
      }, [1, 2]);
    });
    return it("toString", function() {
      return expect(Bacon.never().takeWhile(true).toString()).to.equal("Bacon.never().takeWhile(function)");
    });
  });

  describe("EventStream.skip", function() {
    describe("should skip first N items", function() {
      return expectStreamEvents(function() {
        return series(1, [1, error(), 2, error(), 3]).skip(1);
      }, [error(), 2, error(), 3]);
    });
    describe("accepts N <= 0", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).skip(-1);
      }, [1, 2]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3]).skip(1);
      }, [2, 3]);
    });
    return it("toString", function() {
      return expect(Bacon.never().skip(1).toString()).to.equal("Bacon.never().skip(1)");
    });
  });

  describe("EventStream.skipWhile", function() {
    describe("skips filter predicate holds true", function() {
      return expectStreamEvents(function() {
        return series(1, [1, error(), 2, error(), 3, 2]).skipWhile(lessThan(3));
      }, [error(), error(), 3, 2]);
    });
    describe("extracts field values", function() {
      return expectStreamEvents(function() {
        return series(1, [
          {
            good: true,
            value: "yes"
          }, {
            good: false,
            value: "no"
          }
        ]).skipWhile(".good").map(".value");
      }, ["no"]);
    });
    describe("can filter by Property value", function() {
      return expectStreamEvents(function() {
        var odd, src;
        src = series(1, [1, 1, 2, 3, 4, 4, 8, 7]);
        odd = src.map(function(x) {
          return x % 2;
        }).toProperty();
        return src.skipWhile(odd);
      }, [2, 3, 4, 4, 8, 7]);
    });
    describe("for synchronous sources", function() {
      return describe("skips filter predicate holds true", function() {
        return expectStreamEvents(function() {
          return Bacon.fromArray([1, 2, 3, 2]).skipWhile(lessThan(3));
        }, [3, 2]);
      });
    });
    return it("toString", function() {
      return expect(Bacon.never().skipWhile(1).toString()).to.equal("Bacon.never().skipWhile(function)");
    });
  });

  describe("EventStream.skipUntil", function() {
    describe("skips events until one appears in given starter stream", function() {
      return expectStreamEvents(function() {
        var src, starter;
        src = series(3, [1, 2, 3]);
        src.onValue(function() {});
        starter = series(4, ["start"]);
        return src.skipUntil(starter);
      }, [2, 3]);
    });
    describe("works with self-derived starter", function() {
      return expectStreamEvents(function() {
        var src, starter;
        src = series(3, [1, 2, 3]);
        starter = src.filter(function(x) {
          return x === 3;
        });
        return src.skipUntil(starter);
      }, [3]);
    });
    describe("works with self-derived starter with an evil twist", function() {
      return expectStreamEvents(function() {
        var data, src, starter;
        src = series(3, [1, 2, 3]);
        data = src.map(function(x) {
          return x;
        });
        data.onValue(function() {});
        starter = src.filter(function(x) {
          return x === 3;
        });
        return data.skipUntil(starter);
      }, [3]);
    });
    return it("toString", function() {
      return expect(Bacon.never().skipUntil(Bacon.once(1)).toString()).to.equal("Bacon.never().skipUntil(Bacon.once(1))");
    });
  });

  describe("EventStream.skipDuplicates", function() {
    it("Drops duplicates with subscribers with non-overlapping subscription time (#211)", function() {
      var b, noDups, round;
      b = new Bacon.Bus();
      noDups = b.skipDuplicates();
      round = function(expected) {
        var values;
        values = [];
        noDups.take(1).onValue(function(x) {
          return values.push(x);
        });
        b.push(1);
        return expect(values).to.deep.equal(expected);
      };
      round([1]);
      round([]);
      return round([]);
    });
    describe("drops duplicates", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, error(), 2, 3, 1]).skipDuplicates();
      }, [1, 2, error(), 3, 1]);
    });
    describe("allows undefined as initial value", function() {
      return expectStreamEvents(function() {
        return series(1, [void 0, void 0, 1, 2]).skipDuplicates();
      }, [void 0, 1, 2]);
    });
    describe("works with custom isEqual function", function() {
      var a, b, c, d, e, isEqual;
      a = {
        x: 1
      };
      b = {
        x: 2
      };
      c = {
        x: 2
      };
      d = {
        x: 3
      };
      e = {
        x: 1
      };
      isEqual = function(a, b) {
        return (a != null ? a.x : void 0) === (b != null ? b.x : void 0);
      };
      return expectStreamEvents(function() {
        return series(1, [a, b, error(), c, d, e]).skipDuplicates(isEqual);
      }, [a, b, error(), d, e]);
    });
    describe("works with synchrounous sources", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 2, 3, 1]).skipDuplicates();
      }, [1, 2, 3, 1], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.never().skipDuplicates().toString()).to.equal("Bacon.never().skipDuplicates()");
    });
  });

  describe("EventStream.flatMap", function() {
    describe("should spawn new stream for each value and collect results into a single stream", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).flatMap(function(value) {
          return Bacon.sequentially(t(2), [value, error(), value]);
        });
      }, [1, 2, error(), error(), 1, 2], unstable);
    });
    describe("should pass source errors through to the result", function() {
      return expectStreamEvents(function() {
        return series(1, [error(), 1]).flatMap(function(value) {
          return Bacon.later(t(1), value);
        });
      }, [error(), 1]);
    });
    describe("should work with a spawned stream responding synchronously", function() {
      expectStreamEvents(function() {
        return series(1, [1, 2]).flatMap(function(value) {
          return Bacon.never().concat(Bacon.once(value));
        });
      }, [1, 2], unstable);
      return expectStreamEvents(function() {
        return series(1, [1, 2]).flatMap(function(value) {
          return Bacon.never().concat(Bacon.once(value)).concat(Bacon.once("lol"));
        });
      }, [1, "lol", 2, "lol"], unstable);
    });
    describe("should work with a source stream responding synchronously", function() {
      expectStreamEvents(function() {
        return Bacon.fromArray([1, 2]).flatMap(function(value) {
          return Bacon.once(value);
        });
      }, [1, 2]);
      expectStreamEvents(function() {
        return Bacon.fromArray([1, 2]).flatMap(function(value) {
          return Bacon.fromArray([value, value * 10]);
        });
      }, [1, 10, 2, 20]);
      return expectStreamEvents(function() {
        return Bacon.once(1).flatMap(function(value) {
          return Bacon.later(0, value);
        });
      }, [1]);
    });
    describe("Works also when f returns a Property instead of an EventStream", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).flatMap(Bacon.constant);
      }, [1, 2], unstable);
    });
    describe("Works also when f returns a constant value instead of an EventStream", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).flatMap(function(x) {
          return x;
        });
      }, [1, 2], unstable);
    });
    describe("Works also when f returns an Error instead of an EventStream", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).flatMap(function(x) {
          return new Bacon.Error(x);
        });
      }, [new Bacon.Error(1), new Bacon.Error(2)], unstable);
    });
    describe("Accepts a constant EventStream/Property as an alternative to a function", function() {
      expectStreamEvents(function() {
        return Bacon.once("asdf").flatMap(Bacon.constant("bacon"));
      }, ["bacon"]);
      return expectStreamEvents(function() {
        return Bacon.once("asdf").flatMap(Bacon.once("bacon"));
      }, ["bacon"]);
    });
    return it("toString", function() {
      return expect(Bacon.never().flatMap(function() {}).toString()).to.equal("Bacon.never().flatMap(function)");
    });
  });

  describe("Property.flatMap", function() {
    describe("should spawn new stream for all events including Init", function() {
      return expectStreamEvents(function() {
        var once;
        once = function(x) {
          return Bacon.once(x);
        };
        return series(1, [1, 2]).toProperty(0).flatMap(once);
      }, [0, 1, 2], unstable);
    });
    describe("Works also when f returns a Property instead of an EventStream", function() {
      expectStreamEvents(function() {
        return series(1, [1, 2]).toProperty().flatMap(Bacon.constant);
      }, [1, 2], unstable);
      return expectPropertyEvents(function() {
        return series(1, [1, 2]).toProperty().flatMap(Bacon.constant).toProperty();
      }, [1, 2], unstable);
    });
    describe("works for synchronous source", function() {
      return expectStreamEvents(function() {
        var once;
        once = function(x) {
          return Bacon.once(x);
        };
        return Bacon.fromArray([1, 2]).toProperty(0).flatMap(once);
      }, [0, 1, 2], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).flatMap(function() {}).toString()).to.equal("Bacon.constant(1).flatMap(function)");
    });
  });

  describe("EventStream.flatMapLatest", function() {
    describe("spawns new streams but collects values from the latest spawned stream only", function() {
      return expectStreamEvents(function() {
        return series(3, [1, 2]).flatMapLatest(function(value) {
          return Bacon.sequentially(t(2), [value, error(), value]);
        });
      }, [1, 2, error(), 2], unstable);
    });
    describe("Accepts a constant EventStream/Property as an alternative to a function", function() {
      return expectStreamEvents(function() {
        return Bacon.once("asdf").flatMapLatest(Bacon.constant("bacon"));
      }, ["bacon"], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.never().flatMapLatest(function() {}).toString()).to.equal("Bacon.never().flatMapLatest(function)");
    });
  });

  describe("Property.flatMapLatest", function() {
    describe("spawns new streams but collects values from the latest spawned stream only", function() {
      return expectStreamEvents(function() {
        return series(3, [1, 2]).toProperty(0).flatMapLatest(function(value) {
          return Bacon.sequentially(t(2), [value, value]);
        });
      }, [0, 1, 2, 2], unstable);
    });
    describe("Accepts a constant EventStream/Property as an alternative to a function", function() {
      return expectStreamEvents(function() {
        return Bacon.constant("asdf").flatMapLatest(Bacon.constant("bacon"));
      }, ["bacon"], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).flatMapLatest(function() {}).toString()).to.equal("Bacon.constant(1).flatMapLatest(function)");
    });
  });

  describe("EventStream.flatMapFirst", function() {
    describe("spawns new streams and ignores source events until current spawned stream has ended", function() {
      return expectStreamEvents(function() {
        return series(2, [2, 4, 6, 8]).flatMapFirst(function(value) {
          return series(1, ["a" + value, "b" + value, "c" + value]);
        });
      }, ["a2", "b2", "c2", "a6", "b6", "c6"], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.never().flatMapFirst(function() {}).toString()).to.equal("Bacon.never().flatMapFirst(function)");
    });
  });

  describe("EventStream.merge", function() {
    describe("merges two streams and ends when both are exhausted", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = series(1, [1, error(), 2, 3]);
        right = series(1, [4, 5, 6]).delay(t(4));
        return left.merge(right);
      }, [1, error(), 2, 3, 4, 5, 6], unstable);
    });
    describe("respects subscriber return value", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = repeat(2, [1, 3]).take(3);
        right = repeat(3, [2]).take(3);
        return left.merge(right).takeWhile(lessThan(2));
      }, [1]);
    });
    describe("does not duplicate same error from two streams", function() {
      return expectStreamEvents(function() {
        var left, right, src;
        src = series(1, [1, error(), 2, error(), 3]);
        left = src.map(function(x) {
          return x;
        });
        right = src.map(function(x) {
          return x * 2;
        });
        return left.merge(right);
      }, [1, 2, error(), 2, 4, error(), 3, 6]);
    });
    describe("works with synchronous sources", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2]).merge(Bacon.fromArray([3, 4]));
      }, [1, 2, 3, 4]);
    });
    return it("toString", function() {
      return expect(Bacon.once(1).merge(Bacon.once(2)).toString()).to.equal("Bacon.once(1).merge(Bacon.once(2))");
    });
  });

  describe("EventStream.delay", function() {
    describe("delays all events (except errors) by given delay in milliseconds", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = series(2, [1, 2, 3]);
        right = series(1, [error(), 4, 5, 6]).delay(t(6));
        return left.merge(right);
      }, [error(), 1, 2, 3, 4, 5, 6], unstable);
    });
    describe("works with synchronous streams", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = Bacon.fromArray([1, 2, 3]);
        right = Bacon.fromArray([4, 5, 6]).delay(t(6));
        return left.merge(right);
      }, [1, 2, 3, 4, 5, 6], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.never().delay(1).toString()).to.equal("Bacon.never().delay(1)");
    });
  });

  describe("EventStream.debounce", function() {
    describe("throttles input by given delay, passing-through errors", function() {
      return expectStreamEvents(function() {
        return series(2, [1, error(), 2]).debounce(t(7));
      }, [error(), 2]);
    });
    describe("waits for a quiet period before outputing anything", function() {
      return th.expectStreamTimings(function() {
        return series(2, [1, 2, 3, 4]).debounce(t(3));
      }, [[11, 4]]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3, 4]).debounce(t(3));
      }, [4]);
    });
    describe("works in combination with scan", function() {
      var count;
      count = 0;
      expectPropertyEvents(function() {
        return series(2, [1, 2, 3]).debounce(1).scan(0, function(x, y) {
          count++;
          return x + y;
        });
      }, [0, 1, 3, 6]);
      return it("calls accumulator once per value", function() {
        return expect(count).to.equal(3);
      });
    });
    return it("toString", function() {
      return expect(Bacon.never().debounce(1).toString()).to.equal("Bacon.never().debounce(1)");
    });
  });

  describe("EventStream.debounceImmediate(delay)", function() {
    describe("outputs first event immediately, then ignores events for given amount of milliseconds", function() {
      return th.expectStreamTimings(function() {
        return series(2, [1, 2, 3, 4]).debounceImmediate(t(3));
      }, [[2, 1], [6, 3]], unstable);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3, 4]).debounceImmediate(t(3));
      }, [1]);
    });
    return it("toString", function() {
      return expect(Bacon.never().debounceImmediate(1).toString()).to.equal("Bacon.never().debounceImmediate(1)");
    });
  });

  describe("EventStream.throttle(delay)", function() {
    describe("outputs at steady intervals, without waiting for quiet period", function() {
      return th.expectStreamTimings(function() {
        return series(2, [1, 2, 3]).throttle(t(3));
      }, [[5, 2], [8, 3]]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3]).throttle(t(3));
      }, [3]);
    });
    return it("toString", function() {
      return expect(Bacon.never().throttle(1).toString()).to.equal("Bacon.never().throttle(1)");
    });
  });

  describe("EventStream.bufferWithTime", function() {
    describe("returns events in bursts, passing through errors", function() {
      return expectStreamEvents(function() {
        return series(2, [error(), 1, 2, 3, 4, 5, 6, 7]).bufferWithTime(t(7));
      }, [error(), [1, 2, 3, 4], [5, 6, 7]]);
    });
    describe("keeps constant output rate even when input is sporadical", function() {
      return th.expectStreamTimings(function() {
        return th.atGivenTimes([[0, "a"], [3, "b"], [5, "c"]]).bufferWithTime(t(2));
      }, [[2, ["a"]], [4, ["b"]], [6, ["c"]]], unstable);
    });
    describe("works with empty stream", function() {
      return expectStreamEvents(function() {
        return Bacon.never().bufferWithTime(t(1));
      }, []);
    });
    describe("allows custom defer-function", function() {
      var fast;
      fast = function(f) {
        return sc.setTimeout(f, 0);
      };
      return th.expectStreamTimings(function() {
        return th.atGivenTimes([[0, "a"], [2, "b"]]).bufferWithTime(fast);
      }, [[0, ["a"]], [2, ["b"]]]);
    });
    describe("works with synchronous defer-function", function() {
      var sync;
      sync = function(f) {
        return f();
      };
      return th.expectStreamTimings(function() {
        return th.atGivenTimes([[0, "a"], [2, "b"]]).bufferWithTime(sync);
      }, [[0, ["a"]], [2, ["b"]]]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return series(2, [1, 2, 3]).bufferWithTime(t(7));
      }, [[1, 2, 3]]);
    });
    return it("toString", function() {
      return expect(Bacon.never().bufferWithTime(1).toString()).to.equal("Bacon.never().bufferWithTime(1)");
    });
  });

  describe("EventStream.bufferWithCount", function() {
    describe("returns events in chunks of fixed size, passing through errors", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3, error(), 4, 5]).bufferWithCount(2);
      }, [[1, 2], error(), [3, 4], [5]]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3, 4, 5]).bufferWithCount(2);
      }, [[1, 2], [3, 4], [5]]);
    });
    return it("toString", function() {
      return expect(Bacon.never().bufferWithCount(1).toString()).to.equal("Bacon.never().bufferWithCount(1)");
    });
  });

  describe("EventStream.bufferWithTimeOrCount", function() {
    describe("flushes on count", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3, error(), 4, 5]).bufferWithTimeOrCount(t(10), 2);
      }, [[1, 2], error(), [3, 4], [5]]);
    });
    describe("flushes on timeout", function() {
      return expectStreamEvents(function() {
        return series(2, [error(), 1, 2, 3, 4, 5, 6, 7]).bufferWithTimeOrCount(t(7), 10);
      }, [error(), [1, 2, 3, 4], [5, 6, 7]]);
    });
    return it("toString", function() {
      return expect(Bacon.never().bufferWithTimeOrCount(1, 2).toString()).to.equal("Bacon.never().bufferWithTimeOrCount(1,2)");
    });
  });

  describe("EventStream.takeUntil", function() {
    describe("takes elements from source until an event appears in the other stream", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = repeat(3, [1, 2, 3]);
        stopper = repeat(7, ["stop!"]);
        return src.takeUntil(stopper);
      }, [1, 2], unstable);
    });
    describe("works on self-derived stopper", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = repeat(3, [3, 2, 1]);
        stopper = src.filter(lessThan(3));
        return src.takeUntil(stopper);
      }, [3]);
    });
    describe("works on self-derived stopper with an evil twist", function() {
      return expectStreamEvents(function() {
        var data, src, stopper;
        src = repeat(3, [3, 2, 1]);
        data = src.map(function(x) {
          return x;
        });
        data.take(3).onValue(function() {});
        stopper = src.filter(lessThan(3));
        return data.takeUntil(stopper);
      }, [3]);
    });
    describe("includes source errors, ignores stopper errors", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = repeat(2, [1, error(), 2, 3]);
        stopper = repeat(7, ["stop!"]).merge(repeat(1, [error()]));
        return src.takeUntil(stopper);
      }, [1, error(), 2], unstable);
    });
    describe("works with Property as stopper", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = repeat(3, [1, 2, 3]);
        stopper = repeat(7, ["stop!"]).toProperty();
        return src.takeUntil(stopper);
      }, [1, 2], unstable);
    });
    describe("considers Property init value as stopper", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = repeat(3, [1, 2, 3]);
        stopper = Bacon.constant("stop");
        return src.takeUntil(stopper);
      }, []);
    });
    describe("ends immediately with synchronous stopper", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = repeat(3, [1, 2, 3]);
        stopper = Bacon.once("stop");
        return src.takeUntil(stopper);
      }, []);
    });
    describe("ends properly with a never-ending stopper", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = series(1, [1, 2, 3]);
        stopper = new Bacon.Bus();
        return src.takeUntil(stopper);
      }, [1, 2, 3]);
    });
    describe("ends properly with a never-ending stopper and synchronous source", function() {
      return expectStreamEvents(function() {
        var src, stopper;
        src = Bacon.fromArray([1, 2, 3]).mapEnd("finito");
        stopper = new Bacon.Bus();
        return src.takeUntil(stopper);
      }, [1, 2, 3, "finito"]);
    });
    describe("unsubscribes its source as soon as possible", function() {
      return expectStreamEvents(function() {
        var startTick;
        startTick = sc.now();
        return Bacon.later(20).onUnsub(function() {
          return expect(sc.now()).to.equal(startTick + 1);
        }).takeUntil(Bacon.later(1));
      }, []);
    });
    describe("it should unsubscribe its stopper on end", function() {
      return expectStreamEvents(function() {
        var startTick;
        startTick = sc.now();
        return Bacon.later(1, 'x').takeUntil(Bacon.later(20).onUnsub(function() {
          return expect(sc.now()).to.equal(startTick + 1);
        }));
      }, ['x']);
    });
    describe("it should unsubscribe its stopper on no more", function() {
      return expectStreamEvents(function() {
        var startTick;
        startTick = sc.now();
        return Bacon.later(1, 'x').takeUntil(Bacon.later(20).onUnsub(function() {
          return expect(sc.now()).to.equal(startTick + 1);
        }));
      }, ['x']);
    });
    /* TODO does not pass
    describe "works with synchronous self-derived sources", ->
      expectStreamEvents(
        ->
          a = Bacon.fromArray [1,2]
          b = a.filter((x) -> x >= 2)
          a.takeUntil b
        [1])
    */

    return it("toString", function() {
      return expect(Bacon.later(1, "a").takeUntil(Bacon.later(2, "b")).toString()).to.equal("Bacon.later(1,a).takeUntil(Bacon.later(2,b))");
    });
  });

  describe("When an Event triggers another one in the same stream, while dispatching", function() {
    it("Delivers triggered events correctly", function() {
      var bus, values;
      bus = new Bacon.Bus;
      values = [];
      bus.take(2).onValue(function(v) {
        bus.push("A");
        return bus.push("B");
      });
      bus.onValue(function(v) {
        return values.push(v);
      });
      bus.push("a");
      bus.push("b");
      return expect(values).to.deep.equal(["a", "A", "B", "A", "B", "b"]);
    });
    return it("EventStream.take(1) works correctly (bug fix)", function() {
      var bus, values;
      bus = new Bacon.Bus;
      values = [];
      bus.take(1).onValue(function(v) {
        bus.push("onValue triggers a side-effect here");
        return values.push(v);
      });
      bus.push("foo");
      return expect(values).to.deep.equal(["foo"]);
    });
  });

  describe("EventStream.awaiting(other)", function() {
    describe("indicates whether s1 has produced output after s2 (or only the former has output so far)", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, 1]).awaiting(series(3, [2]));
      }, [false, true, false, true]);
    });
    describe("supports Properties", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, 1]).awaiting(series(3, [2]).toProperty());
      }, [false, true, false, true]);
    });
    describe("supports simultaneouts events", function() {
      expectPropertyEvents(function() {
        var src;
        src = Bacon.later(1, 1);
        return src.awaiting(src.map(function() {}));
      }, [false]);
      return expectPropertyEvents(function() {
        var src;
        src = Bacon.later(1, 1);
        return src.map(function() {}).awaiting(src);
      }, [false]);
    });
    return it("toString", function() {
      return expect(Bacon.never().awaiting(Bacon.once(1)).toString()).to.equal("Bacon.never().awaiting(Bacon.once(1))");
    });
  });

  describe("EventStream.endOnError", function() {
    describe("terminates on error", function() {
      return expectStreamEvents(function() {
        return repeat(1, [1, 2, error(), 3]).endOnError();
      }, [1, 2, error()]);
    });
    describe("accepts predicate function", function() {
      return expectStreamEvents(function() {
        return series(1, [
          1, 2, error(), 3, new Bacon.Error({
            serious: true
          }), 4
        ]).endOnError(function(e) {
          return e != null ? e.serious : void 0;
        });
      }, [1, 2, error(), 3, error()]);
    });
    describe("accepts extractor string", function() {
      return expectStreamEvents(function() {
        return series(1, [
          1, 2, error(), 3, new Bacon.Error({
            serious: true
          }), 4
        ]).endOnError(".serious");
      }, [1, 2, error(), 3, error()]);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, error(), 3]).endOnError();
      }, [1, 2, error()]);
    });
    return it("toString", function() {
      return expect(Bacon.never().endOnError().toString()).to.equal("Bacon.never().endOnError()");
    });
  });

  describe("Bacon.constant", function() {
    describe("creates a constant property", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant("lol");
      }, ["lol"]);
    });
    it("ignores unsubscribe", function() {
      var _this = this;
      return Bacon.constant("lol").onValue(function() {})();
    });
    describe("provides same value to all listeners", function() {
      var c;
      c = Bacon.constant("lol");
      expectPropertyEvents((function() {
        return c;
      }), ["lol"]);
      return it("check check", function() {
        var f;
        f = mockFunction();
        c.onValue(f);
        return f.verify("lol");
      });
    });
    it("provides same value to all listeners, when mapped (bug fix)", function() {
      var c, f;
      c = Bacon.constant("lol").map(id);
      f = mockFunction();
      c.onValue(f);
      f.verify("lol");
      c.onValue(f);
      return f.verify("lol");
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).toString()).to.equal("Bacon.constant(1)");
    });
  });

  describe("Bacon.never", function() {
    return describe("should send just end", function() {
      return expectStreamEvents(function() {
        return Bacon.never();
      }, []);
    });
  });

  describe("Bacon.once", function() {
    describe("should send single event and end", function() {
      return expectStreamEvents(function() {
        return Bacon.once("pow");
      }, ["pow"]);
    });
    describe("accepts an Error event as parameter", function() {
      return expectStreamEvents(function() {
        return Bacon.once(new Bacon.Error("oop"));
      }, [error()]);
    });
    return describe("Allows wrapped events, for instance, Bacon.Error", function() {
      return expectStreamEvents(function() {
        return Bacon.once(error());
      }, [error()]);
    });
  });

  describe("Bacon.fromArray", function() {
    describe("Turns an empty array into an EventStream", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([]);
      }, []);
    });
    describe("Turns a single-element array into an EventStream", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1]);
      }, [1]);
    });
    describe("Turns a longer array into an EventStream", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3]);
      }, [1, 2, 3]);
    });
    return describe("Allows wrapped events, for instance, Bacon.Error", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([error(), 1]);
      }, [error(), 1]);
    });
  });

  describe("EventStream.concat", function() {
    describe("provides values from streams in given order and ends when both are exhausted", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = series(2, [1, error(), 2, 3]);
        right = series(1, [4, 5, 6]);
        return left.concat(right);
      }, [1, error(), 2, 3, 4, 5, 6], unstable);
    });
    describe("respects subscriber return value when providing events from left stream", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = repeat(3, [1, 3]).take(3);
        right = repeat(2, [1]).take(3);
        return left.concat(right).takeWhile(lessThan(2));
      }, [1]);
    });
    describe("respects subscriber return value when providing events from right stream", function() {
      return expectStreamEvents(function() {
        var left, right;
        left = series(3, [1, 2]);
        right = series(2, [2, 4, 6]);
        return left.concat(right).takeWhile(lessThan(4));
      }, [1, 2, 2]);
    });
    describe("works with Bacon.never()", function() {
      return expectStreamEvents(function() {
        return Bacon.never().concat(Bacon.never());
      }, []);
    });
    describe("works with Bacon.once()", function() {
      return expectStreamEvents(function() {
        return Bacon.once(2).concat(Bacon.once(1));
      }, [2, 1]);
    });
    describe("works with Bacon.once() and Bacon.never()", function() {
      return expectStreamEvents(function() {
        return Bacon.once(1).concat(Bacon.never());
      }, [1]);
    });
    describe("works with Bacon.never() and Bacon.once()", function() {
      return expectStreamEvents(function() {
        return Bacon.never().concat(Bacon.once(1));
      }, [1]);
    });
    describe("works with Bacon.once() and async source", function() {
      return expectStreamEvents(function() {
        return Bacon.once(1).concat(series(1, [2, 3]));
      }, [1, 2, 3]);
    });
    describe("works with Bacon.once() and Bacon.fromArray()", function() {
      return expectStreamEvents(function() {
        return Bacon.once(1).concat(Bacon.fromArray([2, 3]));
      }, [1, 2, 3], unstable);
    });
    describe("Works with synchronized left stream and doAction", function() {
      return expectStreamEvents(function() {
        var bus, stream;
        bus = new Bacon.Bus();
        stream = Bacon.fromArray([1, 2]).flatMapLatest(function(x) {
          return Bacon.once(x).concat(Bacon.later(10, x).doAction(function(x) {
            bus.push(x);
            return bus.end();
          }));
        });
        stream.onValue(function() {});
        return bus;
      }, [2]);
    });
    return it("toString", function() {
      return expect(Bacon.once(1).concat(Bacon.once(2)).toString()).to.equal("Bacon.once(1).concat(Bacon.once(2))");
    });
  });

  describe("EventStream.startWith", function() {
    describe("provides seed value, then the rest", function() {
      return expectStreamEvents(function() {
        var left;
        left = series(1, [1, 2, 3]);
        return left.startWith('pow');
      }, ['pow', 1, 2, 3], unstable);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        var left;
        left = Bacon.fromArray([1, 2, 3]);
        return left.startWith('pow');
      }, ['pow', 1, 2, 3], unstable);
    });
    return it("toString", function() {
      return expect(Bacon.never().startWith(0).toString()).to.equal("Bacon.never().startWith(0)");
    });
  });

  describe("Property.startWith", function() {
    describe("starts with given value if the Property doesn't have an initial value", function() {
      return expectPropertyEvents(function() {
        var left;
        left = series(1, [1, 2, 3]).toProperty();
        return left.startWith('pow');
      }, ['pow', 1, 2, 3], unstable);
    });
    describe("works with synchronous source", function() {
      return expectPropertyEvents(function() {
        var left;
        left = Bacon.fromArray([1, 2, 3]).toProperty();
        return left.startWith('pow');
      }, ['pow', 1, 2, 3], unstable);
    });
    describe("starts with the initial value of the Property if any", function() {
      return expectPropertyEvents(function() {
        var left;
        left = series(1, [1, 2, 3]).toProperty(0);
        return left.startWith('pow');
      }, [0, 1, 2, 3], unstable);
    });
    describe("works with combineAsArray", function() {
      var a, result;
      result = null;
      a = Bacon.constant("lolbal");
      result = Bacon.combineAsArray([a.map(true), a.map(true)]).map("right").startWith("wrong");
      result.onValue(function(x) {
        return result = x;
      });
      return expect(result).to.equal("right");
    });
    return it("toString", function() {
      return expect(Bacon.constant(2).startWith(1).toString()).to.equal("Bacon.constant(2).startWith(1)");
    });
  });

  describe("EventStream.toProperty", function() {
    describe("delivers current value and changes to subscribers", function() {
      return expectPropertyEvents(function() {
        var p, s;
        s = new Bacon.Bus();
        p = s.toProperty("a");
        soon(function() {
          s.push("b");
          return s.end();
        });
        return p;
      }, ["a", "b"]);
    });
    describe("passes through also Errors", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, error(), 2]).toProperty();
      }, [1, error(), 2]);
    });
    describe("supports null as value", function() {
      return expectPropertyEvents(function() {
        return series(1, [null, 1, null]).toProperty(null);
      }, [null, null, 1, null]);
    });
    describe("does not get messed-up by a transient subscriber (bug fix)", function() {
      return expectPropertyEvents(function() {
        var prop,
          _this = this;
        prop = series(1, [1, 2, 3]).toProperty(0);
        prop.subscribe(function(event) {
          return Bacon.noMore;
        });
        return prop;
      }, [0, 1, 2, 3]);
    });
    describe("works with synchronous source", function() {
      expectPropertyEvents(function() {
        return Bacon.fromArray([1, 2, 3]).toProperty();
      }, [1, 2, 3]);
      return expectPropertyEvents(function() {
        return Bacon.fromArray([1, 2, 3]).toProperty(0);
      }, [0, 1, 2, 3]);
    });
    return it("preserves laziness", function() {
      var calls, id;
      calls = 0;
      id = function(x) {
        calls++;
        return x;
      };
      Bacon.fromArray([1, 2, 3, 4, 5]).map(id).toProperty().skip(4).onValue();
      return expect(calls).to.equal(1);
    });
  });

  describe("Property.toEventStream", function() {
    describe("creates a stream that starts with current property value", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2]).toProperty(0).toEventStream();
      }, [0, 1, 2], unstable);
    });
    return describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2]).toProperty(0).toEventStream();
      }, [0, 1, 2], unstable);
    });
  });

  describe("Property.toProperty", function() {
    describe("returns the same Property", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant(1).toProperty();
      }, [1]);
    });
    return it("rejects arguments", function() {
      var e;
      try {
        Bacon.constant(1).toProperty(0);
        return fail();
      } catch (_error) {
        e = _error;
      }
    });
  });

  describe("Property.map", function() {
    return describe("maps property values", function() {
      return expectPropertyEvents(function() {
        var p, s;
        s = new Bacon.Bus();
        p = s.toProperty(1).map(times, 2);
        soon(function() {
          s.push(2);
          s.error();
          return s.end();
        });
        return p;
      }, [2, 4, error()]);
    });
  });

  describe("Property.filter", function() {
    describe("should filter values", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, error(), 2, 3]).toProperty().filter(lessThan(3));
      }, [1, error(), 2]);
    });
    it("preserves old current value if the updated value is non-matching", function() {
      var p, s, values,
        _this = this;
      s = new Bacon.Bus();
      p = s.toProperty().filter(lessThan(2));
      p.onValue(function() {});
      s.push(1);
      s.push(2);
      values = [];
      p.onValue(function(v) {
        return values.push(v);
      });
      return expect(values).to.deep.equal([1]);
    });
    return describe("can filter by Property value", function() {
      return expectPropertyEvents(function() {
        var ok, src;
        src = series(2, [1, 2, 3, 4]).delay(t(1)).toProperty();
        ok = series(2, [false, true, true, false]).toProperty();
        return src.filter(ok);
      }, [2, 3]);
    });
  });

  describe("Property.take(1)", function() {
    describe("takes the Initial event", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).toProperty(0).take(1);
      }, [0]);
    });
    describe("takes the first Next event, if no Initial value", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).toProperty().take(1);
      }, [1]);
    });
    describe("works for constants", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant(1);
      }, [1]);
    });
    return describe("works for never-ending Property", function() {
      expectPropertyEvents(function() {
        return repeat(1, [1, 2, 3]).toProperty(0).take(1);
      }, [0]);
      return expectPropertyEvents(function() {
        return repeat(1, [1, 2, 3]).toProperty().take(1);
      }, [1]);
    });
  });

  describe("Bacon.once().take(1)", function() {
    return describe("works", function() {
      return expectStreamEvents(function() {
        return Bacon.once(1).take(1);
      }, [1]);
    });
  });

  describe("Property.takeWhile", function() {
    describe("takes while predicate is true", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, error("wat"), 2, 3]).toProperty().takeWhile(lessThan(3));
      }, [1, error("wat"), 2]);
    });
    describe("extracts field values", function() {
      return expectPropertyEvents(function() {
        return series(1, [
          {
            good: true,
            value: "yes"
          }, {
            good: false,
            value: "no"
          }
        ]).toProperty().takeWhile(".good").map(".value");
      }, ["yes"]);
    });
    describe("can filter by Property value", function() {
      return expectPropertyEvents(function() {
        var odd, src;
        src = series(1, [1, 1, 2, 3, 4, 4, 8, 7]).toProperty();
        odd = src.map(function(x) {
          return x % 2;
        });
        return src.takeWhile(odd);
      }, [1, 1]);
    });
    return describe("works with never-ending Property", function() {
      return expectPropertyEvents(function() {
        return repeat(1, [1, error("wat"), 2, 3]).toProperty().takeWhile(lessThan(3));
      }, [1, error("wat"), 2]);
    });
  });

  describe("Property.takeUntil", function() {
    describe("takes elements from source until an event appears in the other stream", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, 2, 3]).toProperty().takeUntil(Bacon.later(t(3)));
      }, [1]);
    });
    describe("works with errors", function() {
      return expectPropertyEvents(function() {
        var src, stopper;
        src = repeat(2, [1, error(), 3]);
        stopper = repeat(5, ["stop!"]);
        return src.toProperty(0).takeUntil(stopper);
      }, [0, 1, error()]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).takeUntil(Bacon.never()).toString()).to.equal("Bacon.constant(1).takeUntil(Bacon.never())");
    });
  });

  describe("Property.delay", function() {
    describe("delivers initial value and changes", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).toProperty(0).delay(t(1));
      }, [0, 1, 2, 3]);
    });
    describe("delays changes", function() {
      return expectStreamEvents(function() {
        return series(2, [1, 2, 3]).toProperty().delay(t(2)).changes().takeUntil(Bacon.later(t(5)));
      }, [1], unstable);
    });
    describe("does not delay initial value", function() {
      return expectPropertyEvents(function() {
        return series(3, [1]).toProperty(0).delay(1).takeUntil(Bacon.later(t(2)));
      }, [0]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(0).delay(1).toString()).to.equal("Bacon.constant(0).delay(1)");
    });
  });

  describe("Property.debounce", function() {
    describe("delivers initial value and changes", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, 2, 3]).toProperty(0).debounce(t(1));
      }, [0, 1, 2, 3]);
    });
    describe("throttles changes, but not initial value", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).toProperty(0).debounce(t(4));
      }, [0, 3]);
    });
    describe("works without initial value", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, 2, 3]).toProperty().debounce(t(4));
      }, [3]);
    });
    describe("works with Bacon.constant (bug fix)", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant(1).debounce(1);
      }, [1]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(0).debounce(1).toString()).to.equal("Bacon.constant(0).debounce(1)");
    });
  });

  describe("Property.throttle", function() {
    describe("throttles changes, but not initial value", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, 3]).toProperty(0).throttle(t(4));
      }, [0, 3]);
    });
    describe("works with Bacon.once (bug fix)", function() {
      return expectPropertyEvents(function() {
        return Bacon.once(1).toProperty().throttle(1);
      }, [1]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(0).throttle(1).toString()).to.equal("Bacon.constant(0).throttle(1)");
    });
  });

  describe("Property.endOnError", function() {
    return describe("terminates on Error", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, error(), 2]).toProperty().endOnError();
      }, [1, error()]);
    });
  });

  describe("Property.awaiting(other)", function() {
    return describe("indicates whether p1 has produced output after p2 (or only the former has output so far)", function() {
      return expectPropertyEvents(function() {
        return series(2, [1, 1]).toProperty().awaiting(series(3, [2]));
      }, [false, true, false, true]);
    });
  });

  describe("Property.skipDuplicates", function() {
    describe("drops duplicates", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, error(), 2, 3, 1]).toProperty(0).skipDuplicates();
      }, [0, 1, 2, error(), 3, 1]);
    });
    return describe("Doesn't skip initial value (bug fix #211)", function() {
      var b, p, s;
      b = new Bacon.Bus();
      p = b.toProperty();
      p.onValue(function() {});
      s = p.skipDuplicates();
      b.push('foo');
      describe("series 1", function() {
        return expectPropertyEvents((function() {
          return s.take(1);
        }), ["foo"]);
      });
      describe("series 2", function() {
        return expectPropertyEvents((function() {
          return s.take(1);
        }), ["foo"]);
      });
      return describe("series 3", function() {
        return expectPropertyEvents((function() {
          return s.take(1);
        }), ["foo"]);
      });
    });
  });

  describe("Property.changes", function() {
    describe("sends property change events", function() {
      return expectStreamEvents(function() {
        var p, s;
        s = new Bacon.Bus();
        p = s.toProperty("a").changes();
        soon(function() {
          s.push("b");
          s.error();
          return s.end();
        });
        return p;
      }, ["b", error()]);
    });
    return describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3]).toProperty(0).changes();
      }, [1, 2, 3]);
    });
  });

  describe("Property.combine", function() {
    describe("combines latest values of two properties, with given combinator function, passing through errors", function() {
      return expectPropertyEvents(function() {
        var left, right;
        left = series(2, [1, error(), 2, 3]).toProperty();
        right = series(2, [4, error(), 5, 6]).delay(t(1)).toProperty();
        return left.combine(right, add);
      }, [5, error(), error(), 6, 7, 8, 9]);
    });
    describe("also accepts a field name instead of combinator function", function() {
      return expectPropertyEvents(function() {
        var left, right;
        left = series(1, [[1]]).toProperty();
        right = series(2, [[2]]).toProperty();
        return left.combine(right, ".concat");
      }, [[1, 2]]);
    });
    describe("combines with null values", function() {
      return expectPropertyEvents(function() {
        var left, right;
        left = series(1, [null]).toProperty();
        right = series(1, [null]).toProperty();
        return left.combine(right, function(l, r) {
          return [l, r];
        });
      }, [[null, null]]);
    });
    it("unsubscribes when initial value callback returns Bacon.noMore", function() {
      var bus, calls, other;
      calls = 0;
      bus = new Bacon.Bus();
      other = Bacon.constant(["rolfcopter"]);
      bus.toProperty(["lollerskates"]).combine(other, ".concat").subscribe(function(e) {
        if (!e.isInitial()) {
          calls += 1;
        }
        return Bacon.noMore;
      });
      bus.push(["fail whale"]);
      return expect(calls).to.equal(0);
    });
    describe("does not duplicate same error from two streams", function() {
      return expectPropertyEvents(function() {
        var src;
        src = series(1, ["same", error()]);
        return Bacon.combineAsArray(src, src);
      }, [["same", "same"], error()]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).combine(Bacon.constant(2), (function() {})).toString()).to.equal("Bacon.constant(1).combine(Bacon.constant(2),function)");
    });
  });

  describe("EventStream.combine", function() {
    return describe("converts stream to Property, then combines", function() {
      return expectPropertyEvents(function() {
        var left, right;
        left = series(2, [1, error(), 2, 3]);
        right = series(2, [4, error(), 5, 6]).delay(t(1)).toProperty();
        return left.combine(right, add);
      }, [5, error(), error(), 6, 7, 8, 9]);
    });
  });

  describe("Bacon.groupSimultaneous", function() {
    describe("groups simultaneous values in to arrays", function() {
      return expectStreamEvents(function() {
        var src, stream;
        src = series(1, [1, 2]);
        stream = src.merge(src.map(function(x) {
          return x * 2;
        }));
        return Bacon.groupSimultaneous(stream);
      }, [[[1, 2]], [[2, 4]]]);
    });
    describe("groups simultaneous values from multiple sources in to arrays", function() {
      return expectStreamEvents(function() {
        var src, stream, stream2;
        src = series(1, [1, 2]);
        stream = src.merge(src.map(function(x) {
          return x * 2;
        }));
        stream2 = src.map(function(x) {
          return x * 4;
        });
        return Bacon.groupSimultaneous(stream, stream2);
      }, [[[1, 2], [4]], [[2, 4], [8]]]);
    });
    describe("accepts an array or multiple args", function() {
      return expectStreamEvents(function() {
        return Bacon.groupSimultaneous([Bacon.later(1, 1), Bacon.later(2, 2)]);
      }, [[[1], []], [[], [2]]]);
    });
    describe("returns empty stream for zero sources", function() {
      expectStreamEvents(function() {
        return Bacon.groupSimultaneous();
      }, []);
      return expectStreamEvents(function() {
        return Bacon.groupSimultaneous([]);
      }, []);
    });
    describe("works with synchronous sources", function() {
      expectStreamEvents(function() {
        return Bacon.groupSimultaneous(Bacon.fromArray([1, 2]));
      }, [[[1]], [[2]]]);
      return expectStreamEvents(function() {
        return Bacon.groupSimultaneous(Bacon.fromArray([1, 2]).mapEnd(3));
      }, [[[1]], [[2]], [[3]]]);
    });
    return it("toString", function() {
      return expect(Bacon.groupSimultaneous(Bacon.never()).toString()).to.equal("Bacon.groupSimultaneous(Bacon.never())");
    });
  });

  describe("Property update is atomic", function() {
    describe("in a diamond-shaped combine() network", function() {
      return expectPropertyEvents(function() {
        var a, b, c;
        a = series(1, [1, 2]).toProperty();
        b = a.map(function(x) {
          return x;
        });
        c = a.map(function(x) {
          return x;
        });
        return b.combine(c, function(x, y) {
          return x + y;
        });
      }, [2, 4]);
    });
    describe("in a triangle-shaped combine() network", function() {
      return expectPropertyEvents(function() {
        var a, b;
        a = series(1, [1, 2]).toProperty();
        b = a.map(function(x) {
          return x;
        });
        return a.combine(b, function(x, y) {
          return x + y;
        });
      }, [2, 4]);
    });
    describe("when filter is involved", function() {
      return expectPropertyEvents(function() {
        var a, b;
        a = series(1, [1, 2]).toProperty();
        b = a.map(function(x) {
          return x;
        }).filter(true);
        return a.combine(b, function(x, y) {
          return x + y;
        });
      }, [2, 4]);
    });
    describe("when root property is based on combine*", function() {
      return expectPropertyEvents(function() {
        var a, b, c;
        a = series(1, [1, 2]).toProperty().combine(Bacon.constant(0), function(x, y) {
          return x;
        });
        b = a.map(function(x) {
          return x;
        });
        c = a.map(function(x) {
          return x;
        });
        return b.combine(c, function(x, y) {
          return x + y;
        });
      }, [2, 4]);
    });
    describe("when root is not a Property", function() {
      return expectPropertyEvents(function() {
        var a, b, c;
        a = series(1, [1, 2]);
        b = a.map(function(x) {
          return x;
        });
        c = a.map(function(x) {
          return x;
        });
        return b.combine(c, function(x, y) {
          return x + y;
        });
      }, [2, 4]);
    });
    it("calls combinator function for valid combos only", function() {
      var calls, combinator, out, prop, results, src;
      calls = 0;
      results = [];
      combinator = function(x, y) {
        calls++;
        return x + y;
      };
      src = new Bacon.Bus();
      prop = src.toProperty();
      out = prop.map(function(x) {
        return x;
      }).combine(prop.map(function(x) {
        return x * 2;
      }), combinator).doAction(function() {}).combine(prop, function(x, y) {
        return x;
      });
      out.onValue(function(x) {
        return results.push(x);
      });
      src.push(1);
      src.push(2);
      expect(results).to.deep.equal([3, 6]);
      return expect(calls).to.equal(2);
    });
    return describe("yet respects subscriber return values (bug fix)", function() {
      return expectStreamEvents(function() {
        return Bacon.repeatedly(t(1), [1, 2, 3]).toProperty().changes().take(1);
      }, [1]);
    });
  });

  describe("independent observables created within the dispatch loop", function() {
    it("combineAsArray", function() {
      var calls;
      calls = 0;
      Bacon.once(1).onValue(function() {
        return Bacon.combineAsArray([Bacon.constant(1)]).onValue(function() {
          return calls++;
        });
      });
      return expect(calls).to.equal(1);
    });
    it("combineAsArray.startWith", function() {
      var result;
      result = null;
      Bacon.once(1).onValue(function() {
        var a, s;
        a = Bacon.constant("lolbal");
        s = Bacon.combineAsArray([a, a]).map("right").startWith("wrong");
        return s.onValue(function(x) {
          return result = x;
        });
      });
      return expect(result).to.equal("right");
    });
    it("stream.startWith", function() {
      var result;
      result = null;
      Bacon.once(1).onValue(function() {
        var s;
        s = Bacon.later(1).startWith(0);
        return s.onValue(function(x) {
          return result = x;
        });
      });
      return expect(result).to.equal(0);
    });
    it("combineAsArray.changes.startWith", function() {
      var result;
      result = null;
      Bacon.once(1).onValue(function() {
        var a, s;
        a = Bacon.constant("lolbal");
        s = Bacon.combineAsArray([a, a]).changes().startWith("right");
        return s.onValue(function(x) {
          return result = x;
        });
      });
      return expect(result).to.equal("right");
    });
    it("flatMap", function() {
      var result;
      result = null;
      Bacon.once(1).onValue(function() {
        var a, s;
        a = Bacon.constant("lolbal");
        s = a.flatMap(function(x) {
          return Bacon.once(x);
        });
        return s.onValue(function(x) {
          return result = x;
        });
      });
      return expect(result).to.equal("lolbal");
    });
    it("awaiting", function() {
      var result;
      result = null;
      Bacon.once(1).onValue(function() {
        var a, s;
        a = Bacon.constant(1);
        s = a.awaiting(a.map(function() {}));
        return s.onValue(function(x) {
          return result = x;
        });
      });
      return expect(result).to.equal(false);
    });
    it("concat", function() {
      var result;
      result = [];
      Bacon.once(1).onValue(function() {
        var s;
        s = Bacon.once(1).concat(Bacon.once(2));
        return s.onValue(function(x) {
          return result.push(x);
        });
      });
      return expect(result).to.deep.equal([1, 2]);
    });
    return it("Property.delay", function() {
      var result;
      result = [];
      Bacon.once(1).onValue(function() {
        var c, s;
        c = Bacon.constant(1);
        s = Bacon.combineAsArray([c, c]).delay(1).map(".0");
        return s.onValue(function(x) {
          return result.push(x);
        });
      });
      return expect(result).to.deep.equal([1]);
    });
  });

  describe("when subscribing within the dispatch loop", function() {
    describe("single subscriber", function() {
      describe("up-to-date values are used (skipped bounce)", function() {
        return expectStreamEvents(function() {
          var src, trigger, value;
          src = series(1, [1, 2]);
          trigger = src.map(function(x) {
            return x;
          });
          trigger.onValue(function() {});
          value = src.toProperty();
          value.onValue(function() {});
          return trigger.flatMap(function() {
            return value.take(1);
          });
        }, [1, 2]);
      });
      return describe("delayed bounce (TODO: how to name better)", function() {
        return expectStreamEvents(function() {
          var src, trigger, value;
          src = series(1, [1, 2]);
          trigger = src.map(function(x) {
            return x;
          });
          trigger.onValue(function() {});
          value = src.filter(function(x) {
            return x === 1;
          }).toProperty(0);
          value.onValue(function() {});
          return trigger.flatMap(function() {
            return value.take(1);
          });
        }, [0, 1]);
      });
    });
    describe("multiple subscribers", function() {
      describe("up-to-date values are used (skipped bounce)", function() {
        return expectStreamEvents(function() {
          var src, trigger, value;
          src = series(1, [1, 2]);
          trigger = src.map(function(x) {
            return x;
          });
          trigger.onValue(function() {});
          value = src.toProperty();
          value.onValue(function() {});
          return trigger.flatMap(function() {
            value.onValue(function() {});
            return value.take(1);
          });
        }, [1, 2]);
      });
      return describe("delayed bounce (TODO: how to name better)", function() {
        return expectStreamEvents(function() {
          var src, trigger, value;
          src = series(1, [1, 2]);
          trigger = src.map(function(x) {
            return x;
          });
          trigger.onValue(function() {});
          value = src.filter(function(x) {
            return x === 1;
          }).toProperty(0);
          value.onValue(function() {});
          return trigger.flatMap(function() {
            value.onValue(function() {});
            return value.take(1);
          });
        }, [0, 1]);
      });
    });
    describe("delayed bounce in case Property ended (bug fix)", function() {
      return expectStreamEvents(function() {
        var bus, root;
        bus = new Bacon.Bus();
        root = Bacon.once(0).toProperty();
        root.onValue(function() {});
        Bacon.later(1).onValue(function() {
          return root.map(function() {
            return 1;
          }).subscribe(function(event) {
            if (event.isEnd()) {
              return bus.end();
            } else {
              return bus.push(event.value());
            }
          });
        });
        return bus;
      }, [1]);
    });
    return describe("poking for errors 2", function() {
      return expectStreamEvents(function() {
        var bus, outdatedChild, root;
        bus = new Bacon.Bus();
        root = Bacon.sequentially(1, [1, 2]).toProperty();
        root.subscribe(function(event) {});
        outdatedChild = root.filter(function(x) {
          return x === 1;
        }).map(function(x) {
          return x;
        });
        outdatedChild.onValue(function() {});
        Bacon.later(3).onValue(function() {
          return outdatedChild.subscribe(function(event) {
            if (event.isEnd()) {
              return bus.end();
            } else {
              return bus.push(event.value());
            }
          });
        });
        return bus;
      }, [1]);
    });
  });

  describe("Bacon.combineAsArray", function() {
    describe("initial value", function() {
      var event;
      event = null;
      before(function() {
        var prop;
        prop = Bacon.constant(1);
        return Bacon.combineAsArray(prop).subscribe(function(x) {
          if (x.hasValue()) {
            return event = x;
          }
        });
      });
      return it("is output as Initial event", function() {
        return expect(event.isInitial()).to.equal(true);
      });
    });
    describe("combines properties and latest values of streams, into a Property having arrays as values", function() {
      return expectPropertyEvents(function() {
        var stream;
        stream = series(1, ["a", "b"]);
        return Bacon.combineAsArray([Bacon.constant(1), Bacon.constant(2), stream]);
      }, [[1, 2, "a"], [1, 2, "b"]]);
    });
    describe("Works with streams provided as a list of arguments as well as with a single array arg", function() {
      return expectPropertyEvents(function() {
        var stream;
        stream = series(1, ["a", "b"]);
        return Bacon.combineAsArray(Bacon.constant(1), Bacon.constant(2), stream);
      }, [[1, 2, "a"], [1, 2, "b"]]);
    });
    describe("works with single property", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray([Bacon.constant(1)]);
      }, [[1]]);
    });
    describe("works with single stream", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray([Bacon.once(1)]);
      }, [[1]]);
    });
    describe("works with arrays as values, with first array being empty (bug fix)", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray([Bacon.constant([]), Bacon.constant([1])]);
      }, [[[], [1]]]);
    });
    describe("works with arrays as values, with first array being non-empty (bug fix)", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray([Bacon.constant([1]), Bacon.constant([2])]);
      }, [[[1], [2]]]);
    });
    describe("works with empty array", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray([]);
      }, [[]]);
    });
    describe("works with empty args list", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray();
      }, [[]]);
    });
    describe("accepts constant values instead of Observables", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineAsArray(Bacon.constant(1), 2, 3);
      }, [[1, 2, 3]]);
    });
    it("preserves laziness", function() {
      var calls, id;
      calls = 0;
      id = function(x) {
        calls++;
        return x;
      };
      Bacon.combineAsArray(Bacon.fromArray([1, 2, 3, 4, 5]).map(id)).skip(4).onValue();
      return expect(calls).to.equal(1);
    });
    return it("toString", function() {
      return expect(Bacon.combineAsArray(Bacon.never()).toString()).to.equal("Bacon.combineAsArray(Bacon.never())");
    });
  });

  describe("Bacon.combineWith", function() {
    describe("combines n properties, streams and constants using an n-ary function", function() {
      return expectPropertyEvents(function() {
        var f, stream;
        stream = series(1, [1, 2]);
        f = function(x, y, z) {
          return x + y + z;
        };
        return Bacon.combineWith(f, stream, Bacon.constant(10), 100);
      }, [111, 112]);
    });
    describe("works with single input", function() {
      return expectPropertyEvents(function() {
        var f, stream;
        stream = series(1, [1, 2]);
        f = function(x) {
          return x * 2;
        };
        return Bacon.combineWith(f, stream);
      }, [2, 4]);
    });
    describe("works with 0 inputs (results to a constant)", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineWith(function() {
          return 1;
        });
      }, [1]);
    });
    return it("toString", function() {
      return expect(Bacon.combineWith((function() {}), Bacon.never()).toString()).to.equal("Bacon.combineWith(function,Bacon.never())");
    });
  });

  describe("Boolean logic", function() {
    describe("combines Properties with and()", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant(true).and(Bacon.constant(false));
      }, [false]);
    });
    describe("combines Properties with or()", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant(true).or(Bacon.constant(false));
      }, [true]);
    });
    describe("inverts property with not()", function() {
      return expectPropertyEvents(function() {
        return Bacon.constant(true).not();
      }, [false]);
    });
    describe("accepts constants instead of properties", function() {
      describe("true and false", function() {
        return expectPropertyEvents(function() {
          return Bacon.constant(true).and(false);
        }, [false]);
      });
      describe("true and true", function() {
        return expectPropertyEvents(function() {
          return Bacon.constant(true).and(true);
        }, [true]);
      });
      return describe("true or false", function() {
        return expectPropertyEvents(function() {
          return Bacon.constant(true).or(false);
        }, [true]);
      });
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).and(Bacon.constant(2).not()).or(Bacon.constant(3)).toString()).to.equal("Bacon.constant(1).and(Bacon.constant(2).not()).or(Bacon.constant(3))");
    });
  });

  describe("Bacon.mergeAll", function() {
    describe("merges all given streams", function() {
      return expectStreamEvents(function() {
        return Bacon.mergeAll([series(3, [1, 2]), series(3, [3, 4]).delay(t(1)), series(3, [5, 6]).delay(t(2))]);
      }, [1, 3, 5, 2, 4, 6], unstable);
    });
    describe("supports n-ary syntax", function() {
      return expectStreamEvents(function() {
        return Bacon.mergeAll(series(3, [1, 2]), series(3, [3, 4]).delay(t(1)), series(3, [5, 6]).delay(t(2)));
      }, [1, 3, 5, 2, 4, 6], unstable);
    });
    describe("works with a single stream", function() {
      expectStreamEvents(function() {
        return Bacon.mergeAll([Bacon.once(1)]);
      }, [1]);
      return expectStreamEvents(function() {
        return Bacon.mergeAll(Bacon.once(1));
      }, [1]);
    });
    describe("returns empty stream for zero input", function() {
      expectStreamEvents(function() {
        return Bacon.mergeAll([]);
      }, []);
      return expectStreamEvents(function() {
        return Bacon.mergeAll();
      }, []);
    });
    return it("toString", function() {
      return expect(Bacon.mergeAll(Bacon.never()).toString()).to.equal("Bacon.mergeAll(Bacon.never())");
    });
  });

  describe("Property.sampledBy(stream)", function() {
    describe("samples property at events, resulting to EventStream", function() {
      return expectStreamEvents(function() {
        var prop, stream;
        prop = series(2, [1, 2]).toProperty();
        stream = repeat(3, ["troll"]).take(4);
        return prop.sampledBy(stream);
      }, [1, 2, 2, 2]);
    });
    describe("includes errors from both Property and EventStream", function() {
      return expectStreamEvents(function() {
        var prop, stream;
        prop = series(2, [error(), 2]).toProperty();
        stream = series(3, [error(), "troll"]);
        return prop.sampledBy(stream);
      }, [error(), error(), 2]);
    });
    describe("ends when sampling stream ends", function() {
      return expectStreamEvents(function() {
        var prop, stream;
        prop = repeat(2, [1, 2]).toProperty();
        stream = repeat(2, [""]).delay(t(1)).take(4);
        return prop.sampledBy(stream);
      }, [1, 2, 1, 2]);
    });
    describe("accepts optional combinator function f(Vp, Vs)", function() {
      return expectStreamEvents(function() {
        var prop, stream;
        prop = series(2, ["a", "b"]).toProperty();
        stream = series(2, ["1", "2", "1", "2"]).delay(t(1));
        return prop.sampledBy(stream, add);
      }, ["a1", "b2", "b1", "b2"]);
    });
    describe("allows method name instead of function too", function() {
      return expectStreamEvents(function() {
        return Bacon.constant([1]).sampledBy(Bacon.once([2]), ".concat");
      }, [[1, 2]]);
    });
    describe("works with same origin", function() {
      expectStreamEvents(function() {
        var src;
        src = series(2, [1, 2]);
        return src.toProperty().sampledBy(src);
      }, [1, 2]);
      return expectStreamEvents(function() {
        var src;
        src = series(2, [1, 2]);
        return src.toProperty().sampledBy(src.map(times, 2));
      }, [1, 2]);
    });
    describe("uses updated property after combine", function() {
      var latter;
      latter = function(a, b) {
        return b;
      };
      return expectPropertyEvents(function() {
        var combined, src;
        src = series(2, ["b", "c"]).toProperty("a");
        combined = Bacon.constant().combine(src, latter);
        return src.sampledBy(combined, add);
      }, ["aa", "bb", "cc"]);
    });
    describe("uses updated property after combine with subscriber", function() {
      var latter;
      latter = function(a, b) {
        return b;
      };
      return expectPropertyEvents(function() {
        var combined, src;
        src = series(2, ["b", "c"]).toProperty("a");
        combined = Bacon.constant().combine(src, latter);
        combined.onValue(function() {});
        return src.sampledBy(combined, add);
      }, ["aa", "bb", "cc"]);
    });
    describe("skips samplings that occur before the property gets its first value", function() {
      expectStreamEvents(function() {
        var p;
        p = series(5, [1]).toProperty();
        return p.sampledBy(series(3, [0]));
      }, []);
      expectStreamEvents(function() {
        var p;
        p = series(5, [1, 2]).toProperty();
        return p.sampledBy(series(3, [0, 0, 0, 0]));
      }, [1, 1, 2], unstable);
      return expectPropertyEvents(function() {
        var p;
        p = series(5, [1, 2]).toProperty();
        return p.sampledBy(series(3, [0, 0, 0, 0]).toProperty());
      }, [1, 1, 2], unstable);
    });
    describe("works with stream of functions", function() {
      var f;
      f = function() {};
      return expectStreamEvents(function() {
        var p;
        p = series(1, [f]).toProperty();
        return p.sampledBy(series(1, [1, 2, 3]));
      }, [f, f, f]);
    });
    describe("works with synchronous sampler stream", function() {
      expectStreamEvents(function() {
        return Bacon.constant(1).sampledBy(Bacon.fromArray([1, 2, 3]));
      }, [1, 1, 1], unstable);
      return expectStreamEvents(function() {
        return Bacon.later(1, 1).toProperty().sampledBy(Bacon.fromArray([1, 2, 3]));
      }, []);
    });
    describe("laziness", function() {
      var calls;
      calls = 0;
      before(function(done) {
        var id, property, sampled, sampler;
        id = function(x) {
          calls++;
          return x;
        };
        sampler = Bacon.later(5).map(id);
        property = repeat(1, [1]).toProperty().map(id);
        sampled = property.sampledBy(sampler);
        sampled.onValue();
        return sampled.onEnd(done);
      });
      return it("preserves laziness", function() {
        return expect(calls).to.equal(1);
      });
    });
    return it("toString", function() {
      return expect(Bacon.constant(0).sampledBy(Bacon.never()).toString()).to.equal("Bacon.constant(0).sampledBy(Bacon.never(),function)");
    });
  });

  describe("Property.sampledBy(property)", function() {
    describe("samples property at events, resulting to a Property", function() {
      return expectPropertyEvents(function() {
        var prop, sampler;
        prop = series(2, [1, 2]).toProperty();
        sampler = repeat(3, ["troll"]).take(4).toProperty();
        return prop.sampledBy(sampler);
      }, [1, 2, 2, 2]);
    });
    describe("works on an event stream by automatically converting to property", function() {
      return expectPropertyEvents(function() {
        var sampler, stream;
        stream = series(2, [1, 2]);
        sampler = repeat(3, ["troll"]).take(4).toProperty();
        return stream.sampledBy(sampler);
      }, [1, 2, 2, 2]);
    });
    return describe("accepts optional combinator function f(Vp, Vs)", function() {
      return expectPropertyEvents(function() {
        var prop, sampler;
        prop = series(2, ["a", "b"]).toProperty();
        sampler = series(2, ["1", "2", "1", "2"]).delay(t(1)).toProperty();
        return prop.sampledBy(sampler, add);
      }, ["a1", "b2", "b1", "b2"]);
    });
  });

  describe("Property.sample", function() {
    describe("samples property by given interval", function() {
      return expectStreamEvents(function() {
        var prop;
        prop = series(2, [1, 2]).toProperty();
        return prop.sample(t(3)).take(4);
      }, [1, 2, 2, 2]);
    });
    describe("includes all errors", function() {
      return expectStreamEvents(function() {
        var prop;
        prop = series(2, [1, error(), 2]).toProperty();
        return prop.sample(t(5)).take(2);
      }, [error(), 1, 2], unstable);
    });
    describe("works with synchronous source", function() {
      return expectStreamEvents(function() {
        var prop;
        prop = Bacon.constant(1);
        return prop.sample(t(3)).take(4);
      }, [1, 1, 1, 1]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(0).sample(1).toString()).to.equal("Bacon.constant(0).sample(1)");
    });
  });

  describe("EventStream.errors", function() {
    describe("Includes errors only", function() {
      return expectStreamEvents(function() {
        return series(1, [1, error(), 2]).errors();
      }, [error()]);
    });
    return it("toString", function() {
      return expect(Bacon.never().errors().toString()).to.equal("Bacon.never().errors()");
    });
  });

  describe("EventStream.scan", function() {
    describe("accumulates values with given seed and accumulator function, passing through errors", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, error(), 3]).scan(0, add);
      }, [0, 1, 3, error(), 6]);
    });
    describe("also works with method name", function() {
      return expectPropertyEvents(function() {
        return series(1, [[1], [2]]).scan([], ".concat");
      }, [[], [1], [1, 2]]);
    });
    it("yields the seed value immediately", function() {
      var bus, outputs;
      outputs = [];
      bus = new Bacon.Bus();
      bus.scan(0, function() {
        return 1;
      }).onValue(function(value) {
        return outputs.push(value);
      });
      return expect(outputs).to.deep.equal([0]);
    });
    describe("yields null seed value", function() {
      return expectPropertyEvents(function() {
        return series(1, [1]).scan(null, function() {
          return 1;
        });
      }, [null, 1]);
    });
    describe("works with synchronous streams", function() {
      return expectPropertyEvents(function() {
        return Bacon.fromArray([1, 2, 3]).scan(0, (function(x, y) {
          return x + y;
        }));
      }, [0, 1, 3, 6]);
    });
    return describe("calls accumulator function once per value", function() {
      var count;
      count = 0;
      expectPropertyEvents(function() {
        return series(2, [1, 2, 3]).scan(0, function(x, y) {
          count++;
          return x + y;
        });
      }, [0, 1, 3, 6]);
      return it("calls accumulator once per value", function() {
        return expect(count).to.equal(3);
      });
    });
  });

  describe("EventStream.fold", function() {
    describe("folds stream into a single-valued Property, passes through errors", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, error(), 3]).fold(0, add);
      }, [error(), 6]);
    });
    describe("has reduce as synonym", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, error(), 3]).fold(0, add);
      }, [error(), 6]);
    });
    return describe("works with synchronous source", function() {
      return expectPropertyEvents(function() {
        return Bacon.fromArray([1, 2, error(), 3]).fold(0, add);
      }, [error(), 6]);
    });
  });

  describe("Property.scan", function() {
    describe("with Init value, starts with f(seed, init)", function() {
      return expectPropertyEvents(function() {
        return series(1, [2, 3]).toProperty(1).scan(0, add);
      }, [1, 3, 6]);
    });
    describe("without Init value, starts with seed", function() {
      return expectPropertyEvents(function() {
        return series(1, [2, 3]).toProperty().scan(0, add);
      }, [0, 2, 5]);
    });
    describe("treats null seed value like any other value", function() {
      expectPropertyEvents(function() {
        return series(1, [1]).toProperty().scan(null, add);
      }, [null, 1]);
      return expectPropertyEvents(function() {
        return series(1, [2]).toProperty(1).scan(null, add);
      }, [1, 3]);
    });
    return describe("for synchronous source", function() {
      describe("with Init value, starts with f(seed, init)", function() {
        return expectPropertyEvents(function() {
          return Bacon.fromArray([2, 3]).toProperty(1).scan(0, add);
        }, [1, 3, 6]);
      });
      describe("without Init value, starts with seed", function() {
        return expectPropertyEvents(function() {
          return Bacon.fromArray([2, 3]).toProperty().scan(0, add);
        }, [0, 2, 5]);
      });
      return describe("works with synchronously responding empty source", function() {
        return expectPropertyEvents(function() {
          return Bacon.never().toProperty(1).scan(0, add);
        }, [1]);
      });
    });
  });

  describe("EventStream.withStateMachine", function() {
    var f;
    f = function(sum, event) {
      if (event.hasValue()) {
        return [sum + event.value(), []];
      } else if (event.isEnd()) {
        return [
          sum, [
            new Bacon.Next(function() {
              return sum;
            }), event
          ]
        ];
      } else {
        return [sum, [event]];
      }
    };
    return describe("runs state machine on the stream", function() {
      return expectStreamEvents(function() {
        return Bacon.fromArray([1, 2, 3]).withStateMachine(0, f);
      }, [6]);
    });
  });

  describe("Property.withStateMachine", function() {
    return describe("runs state machine on the stream", function() {
      return expectPropertyEvents(function() {
        return Bacon.fromArray([1, 2, 3]).toProperty().withStateMachine(0, function(sum, event) {
          if (event.hasValue()) {
            return [sum + event.value(), []];
          } else if (event.isEnd()) {
            return [
              sum, [
                new Bacon.Next(function() {
                  return sum;
                }), event
              ]
            ];
          } else {
            return [sum, [event]];
          }
        });
      }, [6]);
    });
  });

  describe("Property.fold", function() {
    return describe("Folds Property into a single-valued one", function() {
      return expectPropertyEvents(function() {
        return series(1, [2, 3]).toProperty(1).fold(0, add);
      }, [6]);
    });
  });

  describe("EventStream.diff", function() {
    describe("apply diff function to previous and current values, passing through errors", function() {
      return expectPropertyEvents(function() {
        return series(1, [1, 2, error(), 3]).diff(0, add);
      }, [1, 3, error(), 5]);
    });
    describe("also works with method name", function() {
      return expectPropertyEvents(function() {
        return series(1, [[1], [2]]).diff([0], ".concat");
      }, [[0, 1], [1, 2]]);
    });
    it("does not yields the start value immediately", function() {
      var bus, outputs;
      outputs = [];
      bus = new Bacon.Bus();
      bus.diff(0, function() {
        return 1;
      }).onValue(function(value) {
        return outputs.push(value);
      });
      return expect(outputs).to.deep.equal([]);
    });
    return it("toString", function() {
      return expect(Bacon.once(1).diff(0, (function() {})).toString()).to.equal("Bacon.once(1).diff(0,function)");
    });
  });

  describe("Property.diff", function() {
    describe("with Init value, starts with f(start, init)", function() {
      return expectPropertyEvents(function() {
        return series(1, [2, 3]).toProperty(1).diff(0, add);
      }, [1, 3, 5]);
    });
    describe("without Init value, waits for the first value", function() {
      return expectPropertyEvents(function() {
        return series(1, [2, 3]).toProperty().diff(0, add);
      }, [2, 5]);
    });
    return describe("treats null start value like any other value", function() {
      expectPropertyEvents(function() {
        return series(1, [1]).toProperty().diff(null, add);
      }, [1]);
      return expectPropertyEvents(function() {
        return series(1, [2]).toProperty(1).diff(null, add);
      }, [1, 3]);
    });
  });

  describe("EventStream.zip", function() {
    describe("pairwise combines values from two streams", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3]).zip(series(1, ['a', 'b', 'c']));
      }, [[1, 'a'], [2, 'b'], [3, 'c']]);
    });
    describe("passes through errors", function() {
      return expectStreamEvents(function() {
        return series(2, [1, error(), 2]).zip(series(2, ['a', 'b']).delay(1));
      }, [[1, 'a'], error(), [2, 'b']]);
    });
    describe("completes as soon as possible", function() {
      return expectStreamEvents(function() {
        return series(1, [1]).zip(series(1, ['a', 'b', 'c']));
      }, [[1, 'a']]);
    });
    describe("can zip an observable with itself", function() {
      return expectStreamEvents(function() {
        var obs;
        obs = series(1, ['a', 'b', 'c']);
        return obs.zip(obs.skip(1));
      }, [['a', 'b'], ['b', 'c']]);
    });
    return it("toString", function() {
      return expect(Bacon.never().zip(Bacon.once(1)).toString()).to.equal("Bacon.never().zip(Bacon.once(1))");
    });
  });

  describe("Property.zip", function() {
    return describe("pairwise combines values from two properties", function() {
      return expectStreamEvents(function() {
        return series(1, [1, 2, 3]).toProperty().zip(series(1, ['a', 'b', 'c']).toProperty());
      }, [[1, 'a'], [2, 'b'], [3, 'c']], {
        unstable: unstable
      });
    });
  });

  describe("Bacon.zipAsArray", function() {
    describe("zips an array of streams into a stream of arrays", function() {
      return expectStreamEvents(function() {
        var obs;
        obs = series(1, [1, 2, 3, 4]);
        return Bacon.zipAsArray([obs, obs.skip(1), obs.skip(2)]);
      }, [[1, 2, 3], [2, 3, 4]]);
    });
    describe("supports n-ary syntax", function() {
      return expectStreamEvents(function() {
        var obs;
        obs = series(1, [1, 2, 3, 4]);
        return Bacon.zipAsArray(obs, obs.skip(1));
      }, [[1, 2], [2, 3], [3, 4]]);
    });
    describe("accepts Properties as well as EventStreams", function() {
      return expectStreamEvents(function() {
        var obs;
        obs = series(1, [1, 2, 3, 4]);
        return Bacon.zipAsArray(obs, obs.skip(1), Bacon.constant(5));
      }, [[1, 2, 5]]);
    });
    describe("works with single stream", function() {
      expectStreamEvents(function() {
        var obs;
        obs = series(1, [1, 2]);
        return Bacon.zipAsArray([obs]);
      }, [[1], [2]]);
      return expectStreamEvents(function() {
        var obs;
        obs = series(1, [1, 2]);
        return Bacon.zipAsArray(obs);
      }, [[1], [2]]);
    });
    describe("works with 0 streams (=Bacon.never())", function() {
      expectStreamEvents(function() {
        return Bacon.zipAsArray([]);
      }, []);
      return expectStreamEvents(function() {
        return Bacon.zipAsArray();
      }, []);
    });
    return it("toString", function() {
      return expect(Bacon.zipAsArray(Bacon.never(), Bacon.never()).toString()).to.equal("Bacon.zipAsArray(Bacon.never(),Bacon.never())");
    });
  });

  describe("Bacon.zipWith", function() {
    describe("zips an array of streams with given function", function() {
      return expectStreamEvents(function() {
        var obs;
        obs = series(1, [1, 2, 3, 4]);
        return Bacon.zipWith([obs, obs.skip(1), obs.skip(2)], (function(x, y, z) {
          return x + y + z;
        }));
      }, [1 + 2 + 3, 2 + 3 + 4]);
    });
    describe("supports n-ary syntax", function() {
      return expectStreamEvents(function() {
        var f, obs;
        obs = series(1, [1, 2, 3, 4]);
        f = (function(x, y, z) {
          return x + y + z;
        });
        return Bacon.zipWith(f, obs, obs.skip(1), obs.skip(2));
      }, [1 + 2 + 3, 2 + 3 + 4]);
    });
    describe("works with single stream", function() {
      return expectStreamEvents(function() {
        var f, obs;
        obs = series(1, [1, 2]);
        f = function(x) {
          return x * 2;
        };
        return Bacon.zipWith(f, obs);
      }, [1 * 2, 2 * 2]);
    });
    describe("works with 0 streams (=Bacon.never())", function() {
      expectStreamEvents(function() {
        return Bacon.zipWith([], function() {});
      }, []);
      return expectStreamEvents(function() {
        return Bacon.zipWith(function() {});
      }, []);
    });
    return it("toString", function() {
      return expect(Bacon.zipWith((function() {}), Bacon.never()).toString()).to.equal("Bacon.zipWith(function,Bacon.never())");
    });
  });

  describe("Bacon.when", function() {
    describe("synchronizes on join patterns", function() {
      return expectStreamEvents(function() {
        var a, as, b, bs, _, _ref;
        _ref = ['a', 'b', '_'], a = _ref[0], b = _ref[1], _ = _ref[2];
        as = series(1, [a, _, a, a, _, a, _, _, a, a]).filter(function(x) {
          return x === a;
        });
        bs = series(1, [_, b, _, _, b, _, b, b, _, _]).filter(function(x) {
          return x === b;
        });
        return Bacon.when([as, bs], function(a, b) {
          return a + b;
        }, [as], function(a) {
          return a;
        });
      }, ['a', 'ab', 'a', 'ab', 'ab', 'ab'], unstable);
    });
    describe("consider the join patterns from top to bottom", function() {
      return expectStreamEvents(function() {
        var a, as, b, bs, _, _ref;
        _ref = ['a', 'b', '_'], a = _ref[0], b = _ref[1], _ = _ref[2];
        as = series(1, [a, _, a, a, _, a, _, _, a, a]).filter(function(x) {
          return x === a;
        });
        bs = series(1, [_, b, _, _, b, _, b, b, _, _]).filter(function(x) {
          return x === b;
        });
        return Bacon.when([as], function(a) {
          return a;
        }, [as, bs], function(a, b) {
          return a + b;
        });
      }, ['a', 'a', 'a', 'a', 'a', 'a']);
    });
    describe("handles any number of join patterns", function() {
      return expectStreamEvents(function() {
        var a, as, b, bs, c, cs, _, _ref;
        _ref = ['a', 'b', 'c', '_'], a = _ref[0], b = _ref[1], c = _ref[2], _ = _ref[3];
        as = series(1, [a, _, a, _, a, _, a, _, _, _, a, a]).filter(function(x) {
          return x === a;
        });
        bs = series(1, [_, b, _, _, _, b, _, b, _, b, _, _]).filter(function(x) {
          return x === b;
        });
        cs = series(1, [_, _, _, c, _, _, _, _, c, _, _, _]).filter(function(x) {
          return x === c;
        });
        return Bacon.when([as, bs, cs], function(a, b, c) {
          return a + b + c;
        }, [as, bs], function(a, b) {
          return a + b;
        }, [as], function(a) {
          return a;
        });
      }, ['a', 'ab', 'a', 'abc', 'abc', 'ab'], unstable);
    });
    describe("does'nt synchronize on properties", function() {
      expectStreamEvents(function() {
        var p, s;
        p = repeat(1, ["p"]).take(100).toProperty();
        s = series(3, ["1", "2", "3"]);
        return Bacon.when([p, s], function(p, s) {
          return p + s;
        });
      }, ["p1", "p2", "p3"]);
      expectStreamEvents(function() {
        var p, s;
        p = series(3, ["p"]).toProperty();
        s = series(1, ["1"]);
        return Bacon.when([p, s], function(p, s) {
          return p + s;
        });
      }, []);
      expectStreamEvents(function() {
        var p, s;
        p = repeat(1, ["p"]).take(100).toProperty();
        s = series(3, ["1", "2", "3"]).toProperty();
        return Bacon.when([p, s], function(p, s) {
          return p + s;
        });
      }, []);
      return expectStreamEvents(function() {
        var a, as, b, bs, c, cs, _, _ref;
        _ref = ['a', 'b', 'c', '_'], a = _ref[0], b = _ref[1], c = _ref[2], _ = _ref[3];
        as = series(1, [a, _, a, _, a, _, a, _, _, _, a, _, a]).filter(function(x) {
          return x === a;
        });
        bs = series(1, [_, b, _, _, _, b, _, b, _, b, _, _, _]).filter(function(x) {
          return x === b;
        });
        cs = series(1, [_, _, _, c, _, _, _, _, c, _, _, c, _]).filter(function(x) {
          return x === c;
        }).map(1).scan(0, (function(x, y) {
          return x + y;
        }));
        return Bacon.when([as, bs, cs], function(a, b, c) {
          return a + b + c;
        }, [as], function(a) {
          return a;
        });
      }, ['a', 'ab0', 'a', 'ab1', 'ab2', 'ab3'], unstable);
    });
    describe("doesn't output before properties have values", function() {
      return expectStreamEvents(function() {
        var p, s;
        p = series(2, ["p"]);
        s = series(1, ["s"]);
        return Bacon.when([s, p], function(s, p) {
          return s + p;
        });
      }, ["sp"]);
    });
    describe("returns Bacon.never() on the empty list of patterns", function() {
      return expectStreamEvents(function() {
        return Bacon.when();
      }, []);
    });
    describe("returns Bacon.never() when all patterns are zero-length", function() {
      return expectStreamEvents(function() {
        return Bacon.when([], function() {});
      }, []);
    });
    describe("works with empty patterns", function() {
      return expectStreamEvents(function() {
        return Bacon.when([Bacon.once(1)], function(x) {
          return x;
        }, [], function() {});
      }, [1]);
    });
    describe("works with empty patterns (2)", function() {
      return expectStreamEvents(function() {
        return Bacon.when([], function() {}, [Bacon.once(1)], function(x) {
          return x;
        });
      }, [1]);
    });
    describe("works with single stream", function() {
      return expectStreamEvents(function() {
        return Bacon.when([Bacon.once(1)], function(x) {
          return x;
        });
      }, [1]);
    });
    describe("works with multiples of streams", function() {
      return expectStreamEvents(function() {
        var c, cs, h, hs, o, os, _, _ref;
        _ref = ['h', 'o', 'c', '_'], h = _ref[0], o = _ref[1], c = _ref[2], _ = _ref[3];
        hs = series(1, [h, _, h, _, h, _, h, _, _, _, h, _, h]).filter(function(x) {
          return x === h;
        });
        os = series(1, [_, o, _, _, _, o, _, o, _, o, _, _, _]).filter(function(x) {
          return x === o;
        });
        cs = series(1, [_, _, _, c, _, _, _, _, c, _, _, c, _]).filter(function(x) {
          return x === c;
        });
        return Bacon.when([hs, hs, os], function(h1, h2, o) {
          return [h1, h2, o];
        }, [cs, os], function(c, o) {
          return [c, o];
        });
      }, [['h', 'h', 'o'], ['c', 'o'], ['h', 'h', 'o'], ['c', 'o']], unstable);
    });
    describe("works with multiples of properties", function() {
      return expectStreamEvents(function() {
        var c;
        c = Bacon.constant("c");
        return Bacon.when([c, c, Bacon.once(1)], function(c1, c2, _) {
          return c1 + c2;
        });
      }, ["cc"]);
    });
    describe("accepts constants instead of functions too", function() {
      return expectStreamEvents(function() {
        return Bacon.when(Bacon.once(1), 2);
      }, [2]);
    });
    describe("works with synchronous sources", function() {
      return expectStreamEvents(function() {
        var xs, ys;
        xs = Bacon.once("x");
        ys = Bacon.once("y");
        return Bacon.when([xs, ys], function(x, y) {
          return x + y;
        });
      }, ["xy"]);
    });
    return it("toString", function() {
      return expect(Bacon.when([Bacon.never()], (function() {})).toString()).to.equal("Bacon.when([Bacon.never()],function)");
    });
  });

  describe("Bacon.update", function() {
    describe("works like Bacon.when, but produces a property, and can be defined in terms of a current value", function() {
      return expectPropertyEvents(function() {
        var i, incr, r, reset, _, _ref;
        _ref = ['r', 'i', 0], r = _ref[0], i = _ref[1], _ = _ref[2];
        incr = series(1, [1, _, 1, _, 2, _, 1, _, _, _, 2, _, 1]).filter(function(x) {
          return x !== _;
        });
        reset = series(1, [_, r, _, _, _, r, _, r, _, r, _, _, _]).filter(function(x) {
          return x === r;
        });
        return Bacon.update(0, [reset], 0, [incr], function(i, c) {
          return i + c;
        });
      }, [0, 1, 0, 1, 3, 0, 1, 0, 0, 2, 3]);
    });
    describe("Correctly handles multiple arguments in parameter list, and synchronous sources", function() {
      return expectPropertyEvents(function() {
        var one, two;
        one = Bacon.once(1);
        two = Bacon.once(2);
        return Bacon.update(0, [one, two], function(i, a, b) {
          return [i, a, b];
        });
      }, [0, [0, 1, 2]]);
    });
    return it("toString", function() {
      return expect(Bacon.update(0, [Bacon.never()], (function() {})).toString()).to.equal("Bacon.update(0,[Bacon.never()],function)");
    });
  });

  describe("combineTemplate", function() {
    describe("combines streams according to a template object", function() {
      return expectPropertyEvents(function() {
        var firstName, lastName, userName;
        firstName = Bacon.constant("juha");
        lastName = Bacon.constant("paananen");
        userName = Bacon.constant("mr.bacon");
        return Bacon.combineTemplate({
          userName: userName,
          password: "*****",
          fullName: {
            firstName: firstName,
            lastName: lastName
          }
        });
      }, [
        {
          userName: "mr.bacon",
          password: "*****",
          fullName: {
            firstName: "juha",
            lastName: "paananen"
          }
        }
      ]);
    });
    describe("works with a single-stream template", function() {
      return expectPropertyEvents(function() {
        var bacon;
        bacon = Bacon.constant("bacon");
        return Bacon.combineTemplate({
          favoriteFood: bacon
        });
      }, [
        {
          favoriteFood: "bacon"
        }
      ]);
    });
    describe("works when dynamic part is not the last part (bug fix)", function() {
      return expectPropertyEvents(function() {
        var password, username;
        username = Bacon.constant("raimohanska");
        password = Bacon.constant("easy");
        return Bacon.combineTemplate({
          url: "/user/login",
          data: {
            username: username,
            password: password
          },
          type: "post"
        });
      }, [
        {
          url: "/user/login",
          data: {
            username: "raimohanska",
            password: "easy"
          },
          type: "post"
        }
      ]);
    });
    describe("works with arrays as data (bug fix)", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineTemplate({
          x: Bacon.constant([]),
          y: Bacon.constant([[]]),
          z: Bacon.constant(["z"])
        });
      }, [
        {
          x: [],
          y: [[]],
          z: ["z"]
        }
      ]);
    });
    describe("supports empty object", function() {
      return expectPropertyEvents(function() {
        return Bacon.combineTemplate({});
      }, [{}]);
    });
    it("supports arrays", function() {
      var value;
      value = {
        key: [
          {
            x: 1
          }, {
            x: 2
          }
        ]
      };
      Bacon.combineTemplate(value).onValue(function(x) {
        expect(x).to.deep.equal(value);
        return expect(x.key instanceof Array).to.deep.equal(true);
      });
      value = [
        {
          x: 1
        }, {
          x: 2
        }
      ];
      Bacon.combineTemplate(value).onValue(function(x) {
        expect(x).to.deep.equal(value);
        return expect(x instanceof Array).to.deep.equal(true);
      });
      value = {
        key: [
          {
            x: 1
          }, {
            x: 2
          }
        ],
        key2: {}
      };
      Bacon.combineTemplate(value).onValue(function(x) {
        expect(x).to.deep.equal(value);
        return expect(x.key instanceof Array).to.deep.equal(true);
      });
      value = {
        key: [
          {
            x: 1
          }, {
            x: Bacon.constant(2)
          }
        ]
      };
      return Bacon.combineTemplate(value).onValue(function(x) {
        expect(x).to.deep.equal({
          key: [
            {
              x: 1
            }, {
              x: 2
            }
          ]
        });
        return expect(x.key instanceof Array).to.deep.equal(true);
      });
    });
    it("supports nulls", function() {
      var value;
      value = {
        key: null
      };
      return Bacon.combineTemplate(value).onValue(function(x) {
        return expect(x).to.deep.equal(value);
      });
    });
    it("supports NaNs", function() {
      var value;
      value = {
        key: NaN
      };
      return Bacon.combineTemplate(value).onValue(function(x) {
        return expect(isNaN(x.key)).to.deep.equal(true);
      });
    });
    it("supports dates", function() {
      var value;
      value = {
        key: new Date()
      };
      return Bacon.combineTemplate(value).onValue(function(x) {
        return expect(x).to.deep.equal(value);
      });
    });
    it("supports regexps", function() {
      var value;
      value = {
        key: /[0-0]/i
      };
      return Bacon.combineTemplate(value).onValue(function(x) {
        return expect(x).to.deep.equal(value);
      });
    });
    it("supports functions", function() {
      var value;
      value = {
        key: function() {}
      };
      return Bacon.combineTemplate(value).onValue(function(x) {
        return expect(x).to.deep.equal(value);
      });
    });
    return it("toString", function() {
      return expect(Bacon.combineTemplate({
        thing: Bacon.never(),
        "const": "a"
      }).toString()).to.equal("Bacon.combineTemplate({thing:Bacon.never(),const:a})");
    });
  });

  describe("Property.decode", function() {
    describe("switches between source Properties based on property value", function() {
      return expectPropertyEvents(function() {
        var a, b, c;
        a = Bacon.constant("a");
        b = Bacon.constant("b");
        c = Bacon.constant("c");
        return series(1, [1, 2, 3]).toProperty().decode({
          1: a,
          2: b,
          3: c
        });
      }, ["a", "b", "c"]);
    });
    return it("toString", function() {
      return expect(Bacon.constant(1).decode({
        1: "lol"
      }).toString()).to.equal("Bacon.constant(1).decode({1:lol})");
    });
  });

  describe("EventStream.decode", function() {
    return describe("switches between source Properties based on property value", function() {
      return expectPropertyEvents(function() {
        var a, b, c;
        a = Bacon.constant("a");
        b = Bacon.constant("b");
        c = Bacon.constant("c");
        return series(1, [1, 2, 3]).decode({
          1: a,
          2: b,
          3: c
        });
      }, ["a", "b", "c"]);
    });
  });

  describe("Observable.onValues", function() {
    return it("splits value array to callback arguments", function() {
      var f;
      f = mockFunction();
      Bacon.constant([1, 2, 3]).onValues(f);
      return f.verify(1, 2, 3);
    });
  });

  describe("Bacon.onValues", function() {
    return it("is a shorthand for combineAsArray.onValues", function() {
      var f;
      f = mockFunction();
      Bacon.onValues(1, 2, 3, f);
      return f.verify(1, 2, 3);
    });
  });

  describe("Observable.subscribe and onValue", function() {
    return it("returns a dispose() for unsubscribing", function() {
      var dispose, s, values;
      s = new Bacon.Bus();
      values = [];
      dispose = s.onValue(function(value) {
        return values.push(value);
      });
      s.push("lol");
      dispose();
      s.push("wut");
      return expect(values).to.deep.equal(["lol"]);
    });
  });

  describe("Observable.onEnd", function() {
    return it("is called on stream end", function() {
      var ended, s;
      s = new Bacon.Bus();
      ended = false;
      s.onEnd(function() {
        return ended = true;
      });
      s.push("LOL");
      expect(ended).to.deep.equal(false);
      s.end();
      return expect(ended).to.deep.equal(true);
    });
  });

  describe("Field value extraction", function() {
    describe("extracts field value", function() {
      return expectStreamEvents(function() {
        return Bacon.once({
          lol: "wut"
        }).map(".lol");
      }, ["wut"]);
    });
    describe("extracts nested field value", function() {
      return expectStreamEvents(function() {
        return Bacon.once({
          lol: {
            wut: "wat"
          }
        }).map(".lol.wut");
      }, ["wat"]);
    });
    describe("yields 'undefined' if any value on the path is 'undefined'", function() {
      return expectStreamEvents(function() {
        return Bacon.once({}).map(".lol.wut");
      }, [void 0]);
    });
    return it("if field value is method, it does a method call", function() {
      var context, object, result;
      context = null;
      result = null;
      object = {
        method: function() {
          context = this;
          return "result";
        }
      };
      Bacon.once(object).map(".method").onValue(function(x) {
        return result = x;
      });
      expect(result).to.deep.equal("result");
      return expect(context).to.deep.equal(object);
    });
  });

  testSideEffects = function(wrapper, method) {
    return function() {
      it("(f) calls function with property value", function() {
        var f;
        f = mockFunction();
        wrapper("kaboom")[method](f);
        return f.verify("kaboom");
      });
      it("(f, param) calls function, partially applied with param", function() {
        var f;
        f = mockFunction();
        wrapper("kaboom")[method](f, "pow");
        return f.verify("pow", "kaboom");
      });
      it("('.method') calls event value object method", function() {
        var value;
        value = mock("get");
        value.when().get().thenReturn("pow");
        wrapper(value)[method](".get");
        return value.verify().get();
      });
      it("('.method', param) calls event value object method with param", function() {
        var value;
        value = mock("get");
        value.when().get("value").thenReturn("pow");
        wrapper(value)[method](".get", "value");
        return value.verify().get("value");
      });
      it("(object, method) calls object method with property value", function() {
        var target;
        target = mock("pow");
        wrapper("kaboom")[method](target, "pow");
        return target.verify().pow("kaboom");
      });
      it("(object, method, param) partially applies object method with param", function() {
        var target;
        target = mock("pow");
        wrapper("kaboom")[method](target, "pow", "smack");
        return target.verify().pow("smack", "kaboom");
      });
      return it("(object, method, param1, param2) partially applies with 2 args", function() {
        var target;
        target = mock("pow");
        wrapper("kaboom")[method](target, "pow", "smack", "whack");
        return target.verify().pow("smack", "whack", "kaboom");
      });
    };
  };

  describe("Property.onValue", testSideEffects(Bacon.constant, "onValue"));

  describe("Property.assign", testSideEffects(Bacon.constant, "assign"));

  describe("EventStream.onValue", testSideEffects(Bacon.once, "onValue"));

  describe("Property.assign", function() {
    it("calls given objects given method with property values", function() {
      var target;
      target = mock("pow");
      Bacon.constant("kaboom").assign(target, "pow");
      return target.verify().pow("kaboom");
    });
    it("allows partial application of method (i.e. adding fixed args)", function() {
      var target;
      target = mock("pow");
      Bacon.constant("kaboom").assign(target, "pow", "smack");
      return target.verify().pow("smack", "kaboom");
    });
    return it("allows partial application of method with 2 args (i.e. adding fixed args)", function() {
      var target;
      target = mock("pow");
      Bacon.constant("kaboom").assign(target, "pow", "smack", "whack");
      return target.verify().pow("smack", "whack", "kaboom");
    });
  });

  describe("Bacon.Bus", function() {
    it("merges plugged-in streams", function() {
      var bus, dispose, push, values;
      bus = new Bacon.Bus();
      values = [];
      dispose = bus.onValue(function(value) {
        return values.push(value);
      });
      push = new Bacon.Bus();
      bus.plug(push);
      push.push("lol");
      expect(values).to.deep.equal(["lol"]);
      dispose();
      return verifyCleanup();
    });
    describe("works with looped streams", function() {
      return expectStreamEvents(function() {
        var bus,
          _this = this;
        bus = new Bacon.Bus();
        bus.plug(Bacon.later(t(2), "lol"));
        bus.plug(bus.filter(function(value) {
          return "lol" === value;
        }).map(function() {
          return "wut";
        }));
        Bacon.later(t(4)).onValue(function() {
          return bus.end();
        });
        return bus;
      }, ["lol", "wut"]);
    });
    it("dispose works with looped streams", function() {
      var bus, dispose,
        _this = this;
      bus = new Bacon.Bus();
      bus.plug(Bacon.later(t(2), "lol"));
      bus.plug(bus.filter(function(value) {
        return "lol" === value;
      }).map(function() {
        return "wut";
      }));
      dispose = bus.onValue(function() {});
      return dispose();
    });
    it("Removes input from input list on End event", function() {
      var bus, dispose, input, inputSubscribe, subscribed,
        _this = this;
      subscribed = 0;
      bus = new Bacon.Bus();
      input = new Bacon.Bus();
      inputSubscribe = input.subscribe;
      input.subscribe = function(sink) {
        subscribed++;
        return inputSubscribe(sink);
      };
      bus.plug(input);
      dispose = bus.onValue(function() {});
      input.end();
      dispose();
      bus.onValue(function() {});
      return expect(subscribed).to.deep.equal(1);
    });
    it("unsubscribes inputs on end() call", function() {
      var bus, events, input,
        _this = this;
      bus = new Bacon.Bus();
      input = new Bacon.Bus();
      events = [];
      bus.plug(input);
      bus.subscribe(function(e) {
        return events.push(e);
      });
      input.push("a");
      bus.end();
      input.push("b");
      return expect(toValues(events)).to.deep.equal(["a", "<end>"]);
    });
    it("handles cold single-event streams correctly (bug fix)", function() {
      var bus, values;
      values = [];
      bus = new Bacon.Bus();
      bus.plug(Bacon.once("x"));
      bus.plug(Bacon.once("y"));
      bus.onValue(function(x) {
        return values.push(x);
      });
      return expect(values).to.deep.equal(["x", "y"]);
    });
    it("handles end() calls even when there are no subscribers", function() {
      var bus;
      bus = new Bacon.Bus();
      return bus.end();
    });
    describe("delivers pushed events and errors", function() {
      return expectStreamEvents(function() {
        var s;
        s = new Bacon.Bus();
        s.push("pullMe");
        soon(function() {
          s.push("pushMe");
          s.error();
          return s.end();
        });
        return s;
      }, ["pushMe", error()]);
    });
    it("does not deliver pushed events after end() call", function() {
      var bus, called;
      called = false;
      bus = new Bacon.Bus();
      bus.onValue(function() {
        return called = true;
      });
      bus.end();
      bus.push("LOL");
      return expect(called).to.deep.equal(false);
    });
    it("does not plug after end() call", function() {
      var bus, plugged;
      plugged = false;
      bus = new Bacon.Bus();
      bus.end();
      bus.plug(new Bacon.EventStream(function(sink) {
        plugged = true;
        return function() {};
      }));
      bus.onValue(function() {});
      return expect(plugged).to.deep.equal(false);
    });
    it("returns unplug function from plug", function() {
      var bus, src, unplug, values;
      values = [];
      bus = new Bacon.Bus();
      src = new Bacon.Bus();
      unplug = bus.plug(src);
      bus.onValue(function(x) {
        return values.push(x);
      });
      src.push("x");
      unplug();
      src.push("y");
      return expect(values).to.deep.equal(["x"]);
    });
    it("allows consumers to re-subscribe after other consumers have unsubscribed (bug fix)", function() {
      var bus, o, otherBus, unsub;
      bus = new Bacon.Bus;
      otherBus = new Bacon.Bus;
      otherBus.plug(bus);
      unsub = otherBus.onValue(function() {});
      unsub();
      o = [];
      otherBus.onValue(function(v) {
        return o.push(v);
      });
      bus.push("foo");
      return expect(o).to.deep.equal(["foo"]);
    });
    return it("toString", function() {
      return expect(new Bacon.Bus().toString()).to.equal("Bacon.Bus()");
    });
  });

  describe("EventStream", function() {
    describe("works with functions as values (bug fix)", function() {
      expectStreamEvents(function() {
        return Bacon.once(function() {
          return "hello";
        }).map(function(f) {
          return f();
        });
      }, ["hello"]);
      expectStreamEvents(function() {
        return Bacon.once(function() {
          return "hello";
        }).flatMap(Bacon.once).map(function(f) {
          return f();
        });
      }, ["hello"]);
      expectPropertyEvents(function() {
        return Bacon.constant(function() {
          return "hello";
        }).map(function(f) {
          return f();
        });
      }, ["hello"]);
      return expectStreamEvents(function() {
        return Bacon.constant(function() {
          return "hello";
        }).flatMap(Bacon.once).map(function(f) {
          return f();
        });
      }, ["hello"]);
    });
    it("handles one subscriber added twice just like two separate subscribers (case Bacon.noMore)", function() {
      var bus, f, values;
      values = [];
      bus = new Bacon.Bus();
      f = function(v) {
        if (v.hasValue()) {
          values.push(v.value());
          return Bacon.noMore;
        }
      };
      bus.subscribe(f);
      bus.subscribe(f);
      bus.push("bacon");
      return expect(values).to.deep.equal(["bacon", "bacon"]);
    });
    return it("handles one subscriber added twice just like two separate subscribers (case unsub)", function() {
      var bus, f, unsub, values;
      values = [];
      bus = new Bacon.Bus();
      f = function(v) {
        if (v.hasValue()) {
          return values.push(v.value());
        }
      };
      bus.subscribe(f);
      unsub = bus.subscribe(f);
      unsub();
      bus.push("bacon");
      return expect(values).to.deep.equal(["bacon"]);
    });
  });

  describe("Bacon.fromBinder", function() {
    describe("Provides an easier alternative to the EventStream constructor, allowing sending multiple events at a time", function() {
      return expectStreamEvents(function() {
        return Bacon.fromBinder(function(sink) {
          sink([new Bacon.Next(1), new Bacon.End()]);
          return function() {};
        });
      }, [1]);
    });
    describe("Allows sending unwrapped values as well as events", function() {
      return expectStreamEvents(function() {
        return Bacon.fromBinder(function(sink) {
          sink([1, new Bacon.End()]);
          return function() {};
        });
      }, [1]);
    });
    describe("Allows sending single value without wrapping array", function() {
      return expectStreamEvents(function() {
        return Bacon.fromBinder(function(sink) {
          sink(1);
          sink(new Bacon.End());
          return function() {};
        });
      }, [1]);
    });
    return it("toString", function() {
      return expect(Bacon.fromBinder(function() {}).toString()).to.equal("Bacon.fromBinder(function,function)");
    });
  });

  describe("String presentations", function() {
    describe("Initial(1).toString", function() {
      return it("is 1", function() {
        return expect(new Bacon.Initial(1).toString()).to.equal("1");
      });
    });
    describe("Next({a:1i}).toString", function() {
      return it("is {a:1}", function() {
        return expect(new Bacon.Next({
          a: 1
        }).toString()).to.equal("{a:1}");
      });
    });
    describe("Error({a:1}).toString", function() {
      return it("is <error> {a:1}", function() {
        return expect(new Bacon.Error({
          a: 1
        }).toString()).to.equal("<error> {a:1}");
      });
    });
    describe("End.toString", function() {
      return it("is <end>", function() {
        return expect(new Bacon.End().toString()).to.equal("<end>");
      });
    });
    return describe("inspect", function() {
      return it("is the same as toString", function() {
        return expect(new Bacon.Initial(1).inspect()).to.equal("1");
      });
    });
  });

  describe("Observable.name", function() {
    it("sets return value of toString and inspect", function() {
      expect(Bacon.once(1).name("one").toString()).to.equal("one");
      return expect(Bacon.once(1).name("one").inspect()).to.equal("one");
    });
    it("modifies the stream in place", function() {
      var obs;
      obs = Bacon.once(1);
      obs.name("one");
      return expect(obs.toString()).to.equal("one");
    });
    return it("supports composition", function() {
      return expect(Bacon.once("raimohanska").name("raimo").take(1).inspect()).to.equal("raimo.take(1)");
    });
  });

  describe("Bacon.spy", function() {
    var testSpy;
    testSpy = function(expectedCount, f) {
      var calls, spy;
      calls = 0;
      spy = function(obs) {
        return calls++;
      };
      Bacon.spy(spy);
      f();
      return expect(calls).to.equal(expectedCount);
    };
    return describe("calls spy function for all created Observables", function() {
      it("EventStream", function() {
        return testSpy(1, function() {
          return Bacon.once(1);
        });
      });
      it("Property", function() {
        return testSpy(1, function() {
          return Bacon.constant(1);
        });
      });
      it("map", function() {
        return testSpy(2, function() {
          return Bacon.once(1).map(function() {});
        });
      });
      return it("combineTemplate (also called for the intermediate combineAsArray property)", function() {
        return testSpy(4, function() {
          return Bacon.combineTemplate(Bacon.once(1), Bacon.constant(2));
        });
      });
    });
  });

  describe("Infinite synchronous sequences", function() {
    describe("Limiting length with take(n)", function() {
      expectStreamEvents(function() {
        return endlessly(1, 2, 3).take(4);
      }, [1, 2, 3, 1], unstable);
      expectStreamEvents(function() {
        return endlessly(1, 2, 3).take(4).concat(Bacon.once(5));
      }, [1, 2, 3, 1, 5], unstable);
      return expectStreamEvents(function() {
        return endlessly(1, 2, 3).take(4).concat(endlessly(5, 6).take(2));
      }, [1, 2, 3, 1, 5, 6], unstable);
    });
    return describe("With flatMap", function() {
      expectStreamEvents(function() {
        return Bacon.fromArray([1, 2]).flatMap(function(x) {
          return endlessly(x);
        }).take(2);
      }, [1, 1]);
      return expectStreamEvents(function() {
        return endlessly(1, 2).flatMap(function(x) {
          return endlessly(x);
        }).take(2);
      }, [1, 1]);
    });
  });

  endlessly = function() {
    var index, values;
    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    index = 0;
    return Bacon.fromSynchronousGenerator(function() {
      return new Bacon.Next(function() {
        return values[index++ % values.length];
      });
    });
  };

  Bacon.fromGenerator = function(generator) {
    return Bacon.fromBinder(function(sink) {
      var push, unsubd;
      unsubd = false;
      push = function(events) {
        var event, reply, _i, _len;
        events = Bacon._.toArray(events);
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          event = events[_i];
          if (unsubd) {
            return;
          }
          reply = sink(event);
          if (event.isEnd() || reply === Bacon.noMore) {
            return;
          }
        }
        return generator(push);
      };
      push([]);
      return function() {
        return unsubd = true;
      };
    });
  };

  Bacon.fromSynchronousGenerator = function(generator) {
    return Bacon.fromGenerator(function(push) {
      return push(generator());
    });
  };

  lessThan = function(limit) {
    return function(x) {
      return x < limit;
    };
  };

  times = function(x, y) {
    return x * y;
  };

  add = function(x, y) {
    return x + y;
  };

  id = function(x) {
    return x;
  };

}).call(this);
