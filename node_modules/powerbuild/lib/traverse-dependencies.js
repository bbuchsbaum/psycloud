(function() {
  var SourceMapConsumer, badRequireError, canonicalise, escodegen, escope, esprima, estraverse, fs, isCore, isImplicit, path, relativeResolve, sourcemapToAst, util, _,
    __hasProp = {}.hasOwnProperty;

  fs = require('fs');

  path = require('path');

  util = require('util');

  _ = require('lodash');

  esprima = require('esprima');

  estraverse = require('estraverse');

  escodegen = require('escodegen');

  escope = require('escope');

  SourceMapConsumer = require('source-map').SourceMapConsumer;

  sourcemapToAst = require('sourcemap-to-ast');

  canonicalise = require('./canonicalise');

  relativeResolve = require('./relative-resolve');

  isCore = require('./is-core');

  isImplicit = function(name, scope) {
    return _.any(scope.scopes, function(scope) {
      return _.any(scope.references, function(reference) {
        return reference.identifier.name === name && !reference.resolved;
      });
    });
  };

  badRequireError = function(filename, node, msg) {
    var _ref;
    if ((node.loc != null) && (((_ref = node.loc) != null ? _ref.start : void 0) != null)) {
      filename = "" + filename + ":" + node.loc.start.line + ":" + node.loc.start.column;
    }
    throw "illegal require: " + msg + "\n  `" + ((require('escodegen')).generate(node)) + "`\n  in " + filename;
  };

  module.exports = function(build, processedCache) {
    var adjustWrapperLocation, aliases, ast, astOrJs, baseDir, canonicalName, checked, code, consumer, dep, deps, disableSourceMap, dn, e, ep, extname, filename, globalFeatures, id, isCoreModule, isNpmModule, k, lastComment, lineCount, m, map, mapPath, match, mtime, nodeFeatures, processed, realCanonicalName, resolved, resolvedEntryPoints, root, scope, sources, src, worklist, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    aliases = (_ref = build.aliases) != null ? _ref : {};
    root = build.root;
    globalFeatures = {
      console: false,
      setImmediate: false,
      Buffer: false
    };
    worklist = [];
    resolvedEntryPoints = [];
    _ref1 = build.entryPoints;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      ep = _ref1[_i];
      resolved = relativeResolve({
        extensions: build.extensions,
        aliases: aliases,
        root: root,
        path: ep
      });
      worklist.push(_.assign(resolved, {
        isNpmModule: false
      }));
      resolvedEntryPoints.push(resolved.filename);
    }
    build.entryPoints = resolvedEntryPoints;
    if (processedCache) {
      processed = _.clone(processedCache);
    } else {
      processed = {};
    }
    checked = {};
    while (worklist.length) {
      _ref2 = worklist.pop(), filename = _ref2.filename, canonicalName = _ref2.canonicalName, isNpmModule = _ref2.isNpmModule, isCoreModule = _ref2.isCoreModule;
      disableSourceMap = canonicalName in build.disableSourceMap;
      if (!filename) {
        continue;
      }
      if ({}.hasOwnProperty.call(checked, filename)) {
        continue;
      }
      checked[filename] = true;
      extname = path.extname(filename);
      mtime = (fs.statSync(filename)).mtime.getTime();
      if (((_ref3 = processed[filename]) != null ? _ref3.mtime : void 0) === mtime) {
        _ref4 = processed[filename].deps;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          dep = _ref4[_j];
          worklist.push(dep);
        }
        continue;
      }
      src = (fs.readFileSync(filename)).toString();
      astOrJs = {}.hasOwnProperty.call(build.handlers, extname) ? build.handlers[extname](src, canonicalName) : src;
      if (typeof astOrJs === 'string') {
        astOrJs = {
          code: astOrJs
        };
      }
      adjustWrapperLocation = false;
      realCanonicalName = null;
      if (astOrJs.code != null) {
        try {
          astOrJs.code = "(function(){" + astOrJs.code + "})()";
          ast = esprima.parse(astOrJs.code, {
            loc: true,
            comment: true
          });
          ast.body = ast.body[0].expression.callee.body.body;
          adjustWrapperLocation = true;
          ast.loc.end.column -= 4;
          lastComment = ast.comments[ast.comments.length - 1];
          if (lastComment && (match = /[#@] sourceMappingURL=(.+)/.exec(lastComment.value))) {
            dn = path.dirname(filename);
            mapPath = path.join(dn, match[1]);
            m = fs.readFileSync(mapPath, 'utf8');
            consumer = new SourceMapConsumer(m);
            sources = consumer.sources;
            sources[0] = path.resolve(path.join(dn, sources[0]));
            realCanonicalName = path.relative(build.root, sources[0]);
            astOrJs.map = m;
          }
          if (astOrJs.map) {
            sourcemapToAst(ast, astOrJs.map);
          }
        } catch (_error) {
          e = _error;
          if (e.lineNumber) {
            throw new Error("Syntax error in " + filename + " at line " + e.lineNumber + ", column " + e.column + e.message.slice(e.message.indexOf(':')));
          } else {
            throw e;
          }
        }
      } else {
        ast = astOrJs;
      }
      if (ast.loc == null) {
        ast.loc = {};
      }
      scope = escope.analyze(ast);
      deps = [];
      id = build.uidFor(canonicalName);
      estraverse.replace(ast, {
        enter: function(node, parents) {
          var cwd, isCoreDep, isNpmDep, moduleName, rewriteRequire;
          if (node.loc != null) {
            node.loc.source = canonicalName;
            if (node.type !== 'Program' && adjustWrapperLocation) {
              if (node.loc.start.line === 1 && node.loc.start.column >= 12) {
                node.loc.start.column -= 12;
              }
              if (node.loc.end.line === 1 && node.loc.end.column >= 12) {
                node.loc.end.column -= 12;
              }
            }
          }
          if (!(node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'require')) {
            return;
          }
          if (node["arguments"].length !== 1) {
            badRequireError(filename, node, 'require must be given exactly one argument');
          }
          if (!(node["arguments"][0].type === 'Literal' && typeof node["arguments"][0].value === 'string')) {
            badRequireError(filename, node, 'argument of require must be a constant string');
          }
          cwd = path.dirname(fs.realpathSync(filename));
          if (build.verbose) {
            console.error("required \"" + node["arguments"][0].value + "\" from \"" + canonicalName + "\"");
          }
          try {
            moduleName = node["arguments"][0].value;
            rewriteRequire = false;
            if (!(isCoreDep = isCoreModule || isCore(moduleName)) || build.node) {
              rewriteRequire = true;
              resolved = relativeResolve({
                extensions: build.extensions,
                aliases: aliases,
                root: build.root,
                cwd: cwd,
                path: moduleName
              });
              if (resolved) {
                isNpmDep = isNpmModule || /^[^/.]/.test(moduleName);
                dep = _.assign(resolved, {
                  isNpmModule: isNpmDep,
                  isCoreModule: isCoreDep
                });
                worklist.push(dep);
                deps.push(dep);
              }
            }
          } catch (_error) {
            e = _error;
            if (build.ignoreMissing) {
              return {
                type: 'Literal',
                value: null
              };
            }
            throw e;
          }
          if (rewriteRequire) {
            return {
              type: 'CallExpression',
              callee: node.callee,
              "arguments": [
                {
                  type: 'Literal',
                  value: build.uidFor(dep.canonicalName).toString()
                }, {
                  type: 'Identifier',
                  name: 'module'
                }
              ],
              loc: node.loc
            };
          }
        }
      });
      nodeFeatures = {
        __filename: isImplicit('__filename', scope),
        __dirname: isImplicit('__dirname', scope)
      };
      baseDir = path.dirname(path.resolve(__dirname));
      if (!globalFeatures.setImmediate && (isImplicit('setImmediate', scope) || isImplicit('process', scope))) {
        globalFeatures.setImmediate = true;
        resolved = relativeResolve({
          extensions: build.extensions,
          aliases: aliases,
          root: build.root,
          cwd: baseDir,
          path: 'timers'
        });
        resolved = _.extend(resolved, {
          isCoreModule: true,
          isNpmModule: true
        });
        nodeFeatures.setImmediate = resolved.filename;
        worklist.unshift(resolved);
      }
      if (!globalFeatures.console && isImplicit('console', scope)) {
        globalFeatures.console = true;
        resolved = relativeResolve({
          extensions: build.extensions,
          aliases: aliases,
          root: build.root,
          cwd: baseDir,
          path: 'console'
        });
        resolved = _.extend(resolved, {
          isCoreModule: true,
          isNpmModule: true
        });
        nodeFeatures.console = resolved.filename;
        worklist.unshift(resolved);
      }
      if (!globalFeatures.Buffer && isImplicit('Buffer', scope)) {
        globalFeatures.Buffer = true;
        resolved = relativeResolve({
          extensions: build.extensions,
          aliases: aliases,
          root: build.root,
          cwd: baseDir,
          path: 'buffer'
        });
        resolved = _.extend(resolved, {
          isCoreModule: true,
          isNpmModule: true
        });
        nodeFeatures.Buffer = resolved.filename;
        worklist.unshift(resolved);
      }
      _ref5 = escodegen.generate(ast, {
        sourceMap: true,
        format: escodegen.FORMAT_DEFAULTS,
        sourceMapWithCode: true,
        sourceMapRoot: build.sourceMapRoot
      }), code = _ref5.code, map = _ref5.map;
      map = map.toString();
      lineCount = code.split('\n').length;
      processed[filename] = {
        id: id,
        canonicalName: canonicalName,
        code: code,
        map: map,
        lineCount: lineCount,
        mtime: mtime,
        deps: deps,
        nodeFeatures: nodeFeatures,
        isNpmModule: isNpmModule,
        isCoreModule: isCoreModule,
        realCanonicalName: realCanonicalName,
        src: src,
        disableSourceMap: disableSourceMap
      };
      if (processedCache) {
        processedCache[filename] = processed[filename];
      }
    }
    for (k in processed) {
      if (!__hasProp.call(processed, k)) continue;
      isCoreModule = processed[k].isCoreModule;
      if (!(isCoreModule || k in checked)) {
        delete processed[k];
      }
    }
    return processed;
  };

}).call(this);

/*
//@ sourceMappingURL=traverse-dependencies.js.map
*/