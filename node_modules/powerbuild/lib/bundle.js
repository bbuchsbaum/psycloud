(function() {
  var PROCESS, SourceMapConsumer, SourceMapGenerator, UglifyJS, btoa, bundle, commonjs, path, umdOffset, wrap, wrapUmd, _ref,
    __hasProp = {}.hasOwnProperty;

  path = require('path');

  _ref = require('source-map'), SourceMapConsumer = _ref.SourceMapConsumer, SourceMapGenerator = _ref.SourceMapGenerator;

  btoa = require('Base64').btoa;

  UglifyJS = require('uglify-js');

  UglifyJS.AST_Node.warn_function = function() {};

  PROCESS = "(function() { var global = this;\n  var cwd = '/';\n  return {\n    title: 'browser',\n    version: '" + process.version + "',\n    browser: true,\n    env: {},\n    on: function() {},\n    argv: [],\n    nextTick: setImmediate,\n    cwd: function(){ return cwd; },\n    chdir: function(dir){ cwd = dir; }\n  };\n})()";

  commonjs = function(filenameMap) {
    return "(function() {\n  var loading = {};\n  var files = " + (JSON.stringify(filenameMap)) + ";\n  var outer;\n  if (typeof require === 'function') {\n    outer = require;\n  }\n  function inner(id, parentModule) {\n    if({}.hasOwnProperty.call(inner.cache, id))\n      return inner.cache[id];\n\n    if({}.hasOwnProperty.call(loading, id))\n      return loading[id].exports;\n\n    var resolved = inner.resolve(id);\n    if(!resolved && outer) {\n      return inner.cache[id] = outer(id);\n    }\n    if(!resolved) throw new Error(\"Failed to resolve module '\" + id + \"'\");\n\n    var dirname;\n    var filename = files[id] || '';\n    if (filename && typeof __dirname === 'string')\n      filename = __dirname + '/' + filename;\n    if (filename)\n      dirname = filename.slice(0, filename.lastIndexOf('/') + 1);\n    else\n      dirname = '';\n    var module$ = {\n      id: id,\n      require: inner,\n      exports: {},\n      loaded: false,\n      parent: parentModule,\n      children: []\n    };\n    if(parentModule) parentModule.children.push(module$);\n\n    loading[id] = module$;\n    resolved.call(this, module$, module$.exports, dirname, filename);\n    inner.cache[id] = module$.exports;\n    delete loading[id];\n    module$.loaded = true;\n    return inner.cache[id] = module$.exports;\n  }\n\n  inner.modules = {};\n  inner.cache = {};\n\n  inner.resolve = function(id){\n    return {}.hasOwnProperty.call(inner.modules, id) ? inner.modules[id] : void 0;\n  };\n  inner.define = function(id, fn){ inner.modules[id] = fn; };\n\n  return inner;\n})()";
  };

  wrap = function(modules, commonjs) {
    return "(function(require, undefined) { var global = this;\n" + modules + "\n})(" + commonjs + ")";
  };

  wrapUmd = function(exports, commonjs) {
    return "(function(exported) {\n  if (typeof exports === 'object') {\n    module.exports = exported;\n  } else if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return exported;\n    });\n  } else {\n    " + exports + "\n  }\n})(" + commonjs + ");";
  };

  umdOffset = wrapUmd('', '').split('\n').length;

  bundle = function(build, processed) {
    var bufferPath, canonicalName, cjs, code, consolePath, disableSourceMap, entryPoint, exports, filename, files, i, id, isNpmModule, lineCount, lineOffset, map, nodeFeatures, orig, realCanonicalName, req, result, resultMap, setImmediate, _i, _ref1, _ref2;
    result = '';
    resultMap = new SourceMapGenerator({
      file: path.basename(build.output),
      sourceRoot: build.sourceMapRoot
    });
    lineOffset = umdOffset;
    setImmediate = false;
    bufferPath = false;
    consolePath = false;
    files = {};
    for (filename in processed) {
      if (!__hasProp.call(processed, filename)) continue;
      _ref1 = processed[filename], id = _ref1.id, canonicalName = _ref1.canonicalName, realCanonicalName = _ref1.realCanonicalName, code = _ref1.code, map = _ref1.map, lineCount = _ref1.lineCount, isNpmModule = _ref1.isNpmModule, nodeFeatures = _ref1.nodeFeatures, disableSourceMap = _ref1.disableSourceMap;
      if (nodeFeatures.__filename || nodeFeatures.__dirname) {
        files[id] = realCanonicalName || canonicalName;
      }
      setImmediate = setImmediate || nodeFeatures.setImmediate;
      consolePath = consolePath || nodeFeatures.console;
      bufferPath = bufferPath || nodeFeatures.Buffer;
      result += "\nrequire.define('" + id + "', function(module, exports, __dirname, __filename, undefined){\n" + code + "\n});";
      lineOffset += 2;
      if (!disableSourceMap && build.npmSourceMaps || !isNpmModule) {
        orig = new SourceMapConsumer(map);
        orig.eachMapping(function(m) {
          return resultMap.addMapping({
            generated: {
              line: m.generatedLine + lineOffset,
              column: m.generatedColumn
            },
            original: {
              line: m.originalLine || m.generatedLine,
              column: m.originalColumn || m.generatedColumn
            },
            source: realCanonicalName || canonicalName,
            name: m.name
          });
        });
      }
      lineOffset += lineCount;
    }
    if (bufferPath && build.node) {
      id = processed[bufferPath].id;
      result += "\nvar Buffer = require('" + id + "').Buffer;\n";
      result += "if (!Buffer.prototype.toJSON)\n  Buffer.prototype.toJSON = function() {\n    return Array.prototype.slice.call(this, 0);\n  };";
    }
    if (consolePath && build.node) {
      id = processed[consolePath].id;
      result += "\nvar console = require('" + id + "');";
    }
    if (setImmediate && build.node) {
      id = processed[setImmediate].id;
      result += "\nvar setImmediate = require('" + id + "').setImmediate;";
      result += "\nvar process = " + PROCESS + ";";
    }
    for (i = _i = 0, _ref2 = build.entryPoints.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
      entryPoint = build.entryPoints[i];
      id = processed[entryPoint].id;
      if (i === build.entryPoints.length - 1) {
        result += "\nreturn require('" + id + "');";
      } else {
        result += "\nrequire('" + id + "');";
      }
    }
    if (build["export"]) {
      exports = "" + build["export"] + " = exported;";
    } else {
      exports = '';
    }
    req = commonjs(files);
    cjs = wrap(result, req);
    result = wrapUmd(exports, cjs);
    return {
      code: result,
      map: resultMap.toString()
    };
  };

  module.exports = function(build, processed) {
    var canonicalName, code, datauri, filename, map, sm, sourceMappingUrl, src, uglifyAst, _ref1, _ref2;
    _ref1 = bundle(build, processed), code = _ref1.code, map = _ref1.map;
    if (build.minify) {
      uglifyAst = UglifyJS.parse(code);
      if (build.compress) {
        uglifyAst.figure_out_scope();
        uglifyAst = uglifyAst.transform(UglifyJS.Compressor({
          warnings: false
        }));
      }
      uglifyAst.figure_out_scope();
      uglifyAst.compute_char_frequency();
      uglifyAst.mangle_names();
      sm = UglifyJS.SourceMap({
        file: build.output,
        root: build.sourceMapRoot,
        orig: map
      });
      code = uglifyAst.print_to_string({
        source_map: sm
      });
      map = sm.toString();
    }
    if ((build.sourceMap || build.inlineSourceMap) && build.inlineSources) {
      map = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(map));
      for (filename in processed) {
        if (!__hasProp.call(processed, filename)) continue;
        _ref2 = processed[filename], src = _ref2.src, canonicalName = _ref2.canonicalName;
        map.setSourceContent(canonicalName, src);
      }
      map = map.toString();
    }
    if (build.sourceMap) {
      sourceMappingUrl = build.output ? path.relative(path.dirname(build.output), build.sourceMap) : build.sourceMap;
      sourceMappingUrl = build.sourceMappingURLRoot + sourceMappingUrl;
    }
    if (build.inlineSourceMap) {
      datauri = "data:application/json;charset=utf-8;base64," + (btoa("" + map));
      code = "" + code + "\n//# sourceMappingURL=" + datauri;
    } else {
      code = "" + code + "\n//# sourceMappingURL=" + sourceMappingUrl;
    }
    return {
      code: code,
      map: map
    };
  };

}).call(this);

/*
//@ sourceMappingURL=bundle.js.map
*/