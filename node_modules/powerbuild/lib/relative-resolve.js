(function() {
  var CORE_MODULES, canonicalise, fs, isCore, path, resolve, resolvePath,
    __hasProp = {}.hasOwnProperty;

  fs = require('fs');

  path = require('path');

  resolve = require('resolve').sync;

  CORE_MODULES = require('./core-modules');

  isCore = require('./is-core');

  canonicalise = require('./canonicalise');

  resolvePath = function(_arg, pkgMainField) {
    var aliases, corePath, cwd, e, err, extensions, givenPath, k, packageFilter, pkg, pkg_path, root, v, _ref;
    extensions = _arg.extensions, aliases = _arg.aliases, root = _arg.root, cwd = _arg.cwd, givenPath = _arg.path;
    if (pkgMainField == null) {
      pkgMainField = 'browser';
    }
    packageFilter = function(pkg) {
      var k, v, _ref;
      if (typeof pkg[pkgMainField] === 'string') {
        pkg.main = pkg[pkgMainField];
      } else if (typeof pkg[pkgMainField] === 'object') {
        _ref = pkg[pkgMainField];
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          if (v === pkg.main) {
            pkg.main = v;
            break;
          }
        }
      }
      return pkg;
    };
    if (aliases == null) {
      aliases = {};
    }
    if (isCore(givenPath)) {
      if ({}.hasOwnProperty.call(aliases, givenPath)) {
        return;
      }
      corePath = CORE_MODULES[givenPath];
      if (!fs.existsSync(corePath)) {
        throw new Error("Core module \"" + givenPath + "\" has not yet been ported to the browser");
      }
      givenPath = corePath;
    }
    try {
      return resolve(givenPath, {
        extensions: extensions,
        basedir: cwd || root,
        packageFilter: packageFilter
      });
    } catch (_error) {
      e = _error;
      try {
        return resolve(path.join(root, givenPath), {
          extensions: extensions,
          packageFilter: packageFilter
        });
      } catch (_error) {
        e = _error;
        console.error(e);
        err = new Error("Cannot find module \"" + givenPath + "\" in \"" + root + "\"");
        while (cwd !== '/') {
          pkg_path = path.join(cwd, 'package.json');
          if (fs.existsSync(pkg_path)) {
            pkg = JSON.parse(fs.readFileSync(pkg_path, 'utf8'));
            if ('browser' in pkg) {
              _ref = pkg['browser'];
              for (k in _ref) {
                if (!__hasProp.call(_ref, k)) continue;
                v = _ref[k];
                if (k === givenPath && !v) {
                  return null;
                }
              }
            }
            break;
          }
          cwd = path.dirname(cwd);
        }
        throw err;
      }
    }
  };

  module.exports = function(_arg) {
    var aliases, canonicalName, cwd, extensions, givenPath, resolved, root;
    extensions = _arg.extensions, aliases = _arg.aliases, root = _arg.root, cwd = _arg.cwd, givenPath = _arg.path;
    if (aliases == null) {
      aliases = {};
    }
    resolved = resolvePath({
      extensions: extensions,
      aliases: aliases,
      root: root,
      cwd: cwd,
      path: givenPath
    });
    if (resolved) {
      canonicalName = canonicalise(root, resolved);
      if ({}.hasOwnProperty.call(aliases, canonicalName)) {
        resolved = aliases[canonicalName] && resolvePath({
          extensions: extensions,
          aliases: aliases,
          root: root,
          path: aliases[canonicalName]
        });
      }
      return {
        filename: resolved,
        canonicalName: canonicalName
      };
    } else {
      return null;
    }
  };

}).call(this);

/*
//@ sourceMappingURL=relative-resolve.js.map
*/