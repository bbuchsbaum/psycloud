(function() {
  var $0, Powerbuild, aliasPair, build, buildBundle, buildCache, cache, dep, entryPoints, fs, handlerPair, knownOpts, match, nopt, opt, optAliases, options, path, startBuild, stdinput, traverseDependencies, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
    __hasProp = {}.hasOwnProperty;

  fs = require('fs');

  path = require('path');

  nopt = require('nopt');

  _ = require('lodash');

  Powerbuild = require('./index');

  buildCache = require('./build-cache');

  traverseDependencies = require('./traverse-dependencies');

  knownOpts = {};

  _ref = ['deps', 'help', 'ignore-missing', 'inline-source-map', 'inline-sources', 'minify', 'compress', 'node', 'verbose', 'watch', 'cache-path', '--disable-disk-cache', '--npm-source-maps'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    opt = _ref[_i];
    knownOpts[opt] = Boolean;
  }

  _ref1 = ['export', 'output', 'root', 'source-map'];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    opt = _ref1[_j];
    knownOpts[opt] = String;
  }

  _ref2 = ['alias', 'handler'];
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    opt = _ref2[_k];
    knownOpts[opt] = [String, Array];
  }

  optAliases = {
    a: '--alias',
    h: '--handler',
    m: '--minify',
    c: '--compress',
    o: '--output',
    r: '--root',
    s: '--source-map',
    v: '--verbose',
    w: '--watch',
    x: '--export'
  };

  options = nopt(knownOpts, optAliases, process.argv, 2);

  options.entryPoints = entryPoints = _.uniq(options.argv.remain);

  delete options.argv;

  options.ignoreMissing = options['ignore-missing'];

  options.sourceMap = options['source-map'];

  options.inlineSources = options['inline-sources'];

  options.inlineSourceMap = options['inline-source-map'];

  options.cachePath = options['cache-path'];

  options.disableDiskCache = options['cache-path'];

  options.npmSourceMaps = options['npm-source-maps'];

  if (options.help) {
    $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
    $0 = path.basename($0);
    console.log("  Usage: " + $0 + " OPT* ENTRY_FILE+ OPT*  -a, --alias ALIAS:TO      replace requires of file identified by ALIAS with TO  -h, --handler EXT:MODULE  handle files with extension EXT with module MODULE  -m, --minify              minify output using uglify.js  -c, --compress            Compress/optimize code when minifying                            (automatically enabled by this option). Enabling                            will break the generated source map.  -o, --output FILE         output to FILE instead of stdout  -r, --root DIR            unqualified requires are relative to DIR; default: cwd  -s, --source-map FILE     output a source map to FILE  -v, --verbose             verbose output sent to stderr  -w, --watch               watch input files/dependencies for changes and rebuild bundle  -x, --export NAME         export the last given entry module as NAME  --deps                    do not bundle; just list the files that would be bundled  --help                    display this help message and exit  --ignore-missing          continue without error when dependency resolution fails  --inline-source-map       include the source map as a data URI in the generated bundle  --inline-sources          include source content in generated source maps; default: on  --node                    if needed by any module, emulate a node.js                             environment by including globals such as Buffer,                            process and setImmediate; default: on  --cache-path              file where to read/write a json-encoded cache that                            is used for fast, incremental builds.                            default: '.powerbuild-cache~' in the current                            directory  --disable-disk-cache      disables persistence of incremental build cache                            to disk. Incremental build will only work with the                            --watch option  --npm-source-maps         add mappings for npm modules in the resulting                            source map(significantly increases the build time)  --version                 display the version number and exit");
    process.exit(0);
  }

  if (options.version) {
    console.log((require('../package.json')).version);
    process.exit(0);
  }

  if (options.deps) {
    options.processed = {};
    traverseDependencies(options);
    _ref3 = options.processed;
    for (_ in _ref3) {
      if (!__hasProp.call(_ref3, _)) continue;
      dep = _ref3[_];
      console.log(dep.canonicalName);
    }
    process.exit(0);
  }

  if (options.watch && !options.output) {
    console.error('--watch requires --output');
    process.exit(1);
  }

  if (options.alias == null) {
    options.alias = [];
  }

  options.aliases = {};

  _ref4 = options.alias;
  for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
    aliasPair = _ref4[_l];
    if (match = aliasPair.match(/([^:]+):(.*)/ != null ? /([^:]+):(.*)/ : [])) {
      options.aliases[match[1]] = match[2];
    } else {
      throw new Error("invalid alias: " + aliasPair);
    }
  }

  if (options.handler == null) {
    options.handler = [];
  }

  options.handlers = {};

  _ref5 = options.handler;
  for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
    handlerPair = _ref5[_m];
    if (match = handlerPair.match(/([^:]+):(.*)/ != null ? /([^:]+):(.*)/ : [])) {
      options.handlers[match[1]] = require(match[2]);
    } else {
      throw new Error("invalid handler: " + handlerPair);
    }
  }

  buildBundle = function() {
    var code, map, start, _ref6;
    start = new Date().getTime();
    _ref6 = build.bundle(), code = _ref6.code, map = _ref6.map;
    if (build.output) {
      fs.writeFileSync(build.output, code);
      console.error("Created " + build.output);
      if (build.sourceMap) {
        console.error("Created " + build.sourceMap);
        fs.writeFileSync(build.sourceMap, "" + map);
      }
      return console.error("Completed in " + (new Date().getTime() - start) + " ms");
    } else {
      return process.stdout.write("" + code + "\n");
    }
  };

  if (!options.disableDiskCache) {
    cache = buildCache(options.node, options.cachePath);
    options.processed = cache.processed;
    options.uids = cache.uids;
  }

  build = new Powerbuild(options);

  startBuild = function() {
    var building, file, watching, _ref6, _results;
    buildBundle();
    if (options.watch) {
      console.error("Watching for changes...");
      watching = {};
      building = false;
      _ref6 = build.processed;
      _results = [];
      for (file in _ref6) {
        if (!__hasProp.call(_ref6, file)) continue;
        if (!(file in watching)) {
          _results.push((function(file) {
            watching[file] = true;
            return fs.watchFile(file, {
              persistent: true,
              interval: 500
            }, function(curr, prev) {
              var ino;
              if (building) {
                return;
              }
              console.error("File '" + file + "' as changed, starting rebuild");
              building = true;
              ino = process.platform === 'win32' ? curr.ino != null : curr.ino;
              if (!ino) {
                console.error("WARNING: watched file " + file + " has disappeared");
                return;
              }
              buildBundle();
              building = false;
            });
          })(file));
        }
      }
      return _results;
    }
  };

  if (entryPoints.length === 1 && entryPoints[0] === '-') {
    stdinput = '';
    process.stdin.on('data', function(data) {
      return stdinput += data;
    });
    process.stdin.on('end', function() {
      entryPoints[0] = (require('mktemp')).createFileSync('temp-XXXXXXXXX.js');
      fs.writeFileSync(entryPoints[0], stdinput);
      process.on('exit', function() {
        return fs.unlinkSync(entryPoints[0]);
      });
      return startBuild();
    });
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  } else {
    startBuild();
  }

}).call(this);

/*
//@ sourceMappingURL=command.js.map
*/