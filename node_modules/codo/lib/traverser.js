// Generated by CoffeeScript 1.6.3
(function() {
  var CoffeeScript, Documentation, Environment, FS, File, Traverser, _;

  FS = require('fs');

  _ = require('underscore');

  _.str = require('underscore.string');

  CoffeeScript = require('coffee-script');

  Environment = require('./environment');

  Documentation = require('./documentation');

  File = require('./entities/file');

  module.exports = Traverser = (function() {
    Traverser.read = function(file, environment) {
      var content;
      content = FS.readFileSync(file, 'utf8');
      if (!environment.options.cautios) {
        content = this.convertComments(content, environment.options.closure);
      }
      return new this(file, content, environment);
    };

    Traverser.linkAncestors = function(node) {
      var _this = this;
      node.eachChild(function(child) {
        child.ancestor = node;
        return _this.linkAncestors(child);
      });
      return node;
    };

    Traverser.convertComments = function(content, closure) {
      var blockComment, c, comment, commentLine, inBlockComment, inComment, indentComment, line, result, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      if (closure == null) {
        closure = false;
      }
      result = [];
      comment = [];
      inComment = false;
      inBlockComment = false;
      indentComment = 0;
      _ref = content.split('\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        blockComment = /^\s*#{3}/.exec(line) && !/^\s*#{3}.+#{3}/.exec(line);
        if (blockComment || inBlockComment) {
          if (closure) {
            line = line.replace(/#{3}\*/, "###");
          }
          if (blockComment) {
            inBlockComment = !inBlockComment;
          }
          result.push(line);
        } else {
          commentLine = /^(\s*#)\s?(\s*.*)/.exec(line);
          if (commentLine) {
            if (inComment) {
              comment.push(this.whitespace(indentComment) + ((_ref1 = commentLine[2]) != null ? _ref1.replace(/#/g, "\u0091#") : void 0));
            } else {
              inComment = true;
              indentComment = commentLine[1].length - 1;
              comment.push(this.whitespace(indentComment) + '###');
              comment.push(this.whitespace(indentComment) + ((_ref2 = commentLine[2]) != null ? _ref2.replace(/#/g, "\u0091#") : void 0));
            }
          } else {
            if (inComment) {
              inComment = false;
              comment.push(this.whitespace(indentComment) + '###');
              if (/(class\s*[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*|^\s*[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff.]*\s+\=|[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*\s*:\s*(\(.*\)\s*)?[-=]>|@[A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*\s*=\s*(\(.*\)\s*)?[-=]>|^\s*@[$A-Z_][A-Z_]*)|^\s*[$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*:/.exec(line)) {
                for (_j = 0, _len1 = comment.length; _j < _len1; _j++) {
                  c = comment[_j];
                  result.push(c);
                }
              }
              comment = [];
            }
            result.push(line);
          }
        }
      }
      return result.join('\n');
    };

    Traverser.whitespace = function(n) {
      var a;
      a = [];
      while (a.length < n) {
        a.push(' ');
      }
      return a.join('');
    };

    function Traverser(path, content, environment) {
      var _this = this;
      this.path = path;
      this.content = content;
      this.environment = environment;
      if (this.environment == null) {
        this.environment = new Environment;
      }
      this.history = [];
      this.root = this.constructor.linkAncestors(CoffeeScript.nodes(this.content));
      this.file = this.prepare(this.root, this.path, File);
      this.root.traverseChildren(true, function(node) {
        var Entity, _i, _len, _ref;
        _ref = _this.environment.needles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          Entity = _ref[_i];
          if (Entity.looksLike(node)) {
            _this.prepare(node, _this.file, Entity);
          }
        }
        return _this.history.push(node);
      });
    }

    Traverser.prototype.prepare = function(node, file, Entity) {
      var doc, entity, previous;
      if (node.entities == null) {
        node.entities = [];
      }
      if (node.documentation == null) {
        previous = this.history[this.history.length - 1];
        switch (previous != null ? previous.constructor.name : void 0) {
          case 'Comment':
            doc = previous;
            break;
          case 'Literal':
            if (previous.value === 'exports') {
              previous = this.history[this.history.length - 6];
              if ((previous != null ? previous.constructor.name : void 0) === 'Comment') {
                doc = previous;
              }
            }
        }
        if ((doc != null ? doc.comment : void 0) != null) {
          node.documentation = new Documentation(this.leftTrimBlock(doc.comment));
        }
      }
      if (Entity.is(node)) {
        entity = new Entity(this.environment, file, node);
        node.entities.push(entity);
        this.environment.registerEntity(entity);
        return entity;
      }
    };

    Traverser.prototype.leftTrimBlock = function(text) {
      var line, lines, minimalTrim, trimMap;
      if (!text) {
        return;
      }
      lines = text.replace(/\u0091/gm, '').split('\n');
      trimMap = lines.map(function(line) {
        if (line.length !== 0) {
          return line.length - _.str.ltrim(line).length;
        }
      });
      minimalTrim = _.min(_.without(trimMap, void 0));
      if (minimalTrim > 0 && minimalTrim < Infinity) {
        lines = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = lines.length; _i < _len; _i++) {
            line = lines[_i];
            line = line.substring(minimalTrim, line.length);
            _results.push(line);
          }
          return _results;
        })();
      }
      while (lines[0].length === 0) {
        lines = lines.slice(1);
      }
      while (lines[lines.length - 1].length === 0) {
        lines = lines.slice(0, -1);
      }
      return lines;
    };

    Traverser.prototype.inspect = function() {
      return this.environment.inspect();
    };

    return Traverser;

  })();

}).call(this);
