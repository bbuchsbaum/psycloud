// Generated by CoffeeScript 1.6.3
(function() {
  var Entities, MetaMethod, Method, Variable,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Method = require('./method');

  Variable = require('./variable');

  MetaMethod = require('../meta/method');

  Entities = require('../_entities');

  module.exports = Entities.Mixin = (function(_super) {
    __extends(Mixin, _super);

    Mixin.looksLike = function(node) {
      var _ref, _ref1;
      return node.constructor.name === 'Assign' && (((_ref = node.value) != null ? (_ref1 = _ref.base) != null ? _ref1.properties : void 0 : void 0) != null);
    };

    Mixin.is = function(node) {
      var _ref;
      return ((_ref = node.documentation) != null ? _ref.mixin : void 0) && Mixin.__super__.constructor.is.call(this, node);
    };

    Mixin.isConcernSection = function(node) {
      var _ref;
      return node.constructor.name === 'Assign' && ((_ref = node.value) != null ? _ref.constructor.name : void 0) === 'Value' && (node.variable.base.value === 'ClassMethods' || node.variable.base.value === 'InstanceMethods');
    };

    function Mixin(environment, file, node) {
      var name, property, _i, _len, _ref, _ref1;
      this.environment = environment;
      this.file = file;
      this.node = node;
      _ref = this.fetchName(), this.name = _ref[0], this.selfish = _ref[1];
      this.documentation = this.node.documentation;
      this.methods = [];
      this.variables = [];
      this.inclusions = [];
      this.extensions = [];
      this.concerns = [];
      _ref1 = this.node.value.base.properties;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        if (this.constructor.isConcernSection(property)) {
          this.concern = true;
        }
      }
      if (this.concern) {
        this.classMethods = [];
        this.instanceMethods = [];
      }
      name = this.name.split('.');
      this.basename = name.pop();
      this.namespace = name.join('.');
    }

    Mixin.prototype.linkify = function() {
      var property, _i, _len, _ref, _ref1, _results;
      Mixin.__super__.linkify.apply(this, arguments);
      this.grabMethods(this.methods, this.node);
      if (this.concern) {
        _ref = this.node.value.base.properties;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          property = _ref[_i];
          if (((_ref1 = property.value) != null ? _ref1.constructor.name : void 0) === 'Value') {
            switch (property.variable.base.value) {
              case 'ClassMethods':
                _results.push(this.grabMethods(this.classMethods, property));
                break;
              case 'InstanceMethods':
                _results.push(this.grabMethods(this.instanceMethods, property));
                break;
              default:
                _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Mixin.prototype.grabMethods = function(container, node) {
      var entity, property, _i, _len, _ref, _results;
      _ref = node.value.base.properties;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        if (property.entities != null) {
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = property.entities;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              entity = _ref1[_j];
              if (entity instanceof Method) {
                _results1.push(container.push(entity));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Mixin.prototype.aggregateEffectiveMethods = function(kind) {
      var method, methods, overrides, _i, _j, _len, _len1, _ref, _ref1;
      methods = [];
      overrides = {};
      if (kind != null) {
        overrides.kind = kind;
      }
      _ref = this.methods;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        methods.push(MetaMethod.fromMethodEntity(method, overrides));
      }
      if (this.documentation.methods) {
        _ref1 = this.documentation.methods;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          method = _ref1[_j];
          methods.push(MetaMethod.fromDocumentationMethod(method, overrides));
        }
      }
      return methods;
    };

    Mixin.prototype.effectiveMethods = function() {
      if (this.concern) {
        return this.effectiveConcernMethods();
      }
      return this._effectiveMethods || (this._effectiveMethods = this.aggregateEffectiveMethods());
    };

    Mixin.prototype.effectiveInclusionMethods = function() {
      return this._effectiveInclusionMethods || (this._effectiveInclusionMethods = this.aggregateEffectiveMethods('dynamic'));
    };

    Mixin.prototype.effectiveExtensionMethods = function() {
      return this._effectiveExtensionMethods || (this._effectiveExtensionMethods = this.aggregateEffectiveMethods('static'));
    };

    Mixin.prototype.effectiveConcernMethods = function() {
      var method, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (this._effectiveConcernMethods != null) {
        return this._effectiveConcernMethods;
      }
      this._effectiveConcernMethods = [];
      _ref = this.classMethods;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        this._effectiveConcernMethods.push(MetaMethod.fromMethodEntity(method, {
          kind: 'static'
        }));
      }
      _ref1 = this.instanceMethods;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        method = _ref1[_j];
        this._effectiveConcernMethods.push(MetaMethod.fromMethodEntity(method, {
          kind: 'dynamic'
        }));
      }
      if (this.documentation.methods) {
        _ref2 = this.documentation.methods;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          method = _ref2[_k];
          this._effectiveConcernMethods.push(MetaMethod.fromDocumentationMethod(method));
        }
      }
      return this._effectiveConcernMethods;
    };

    Mixin.prototype.inspect = function() {
      var _ref, _ref1, _ref2;
      return {
        file: this.file.path,
        name: this.name,
        concern: this.concern,
        documentation: (_ref = this.documentation) != null ? _ref.inspect() : void 0,
        selfish: this.selfish,
        methods: this.methods.map(function(x) {
          return x.inspect();
        }),
        classMethods: (_ref1 = this.classMethods) != null ? _ref1.map(function(x) {
          return x.inspect();
        }) : void 0,
        instanceMethods: (_ref2 = this.instanceMethods) != null ? _ref2.map(function(x) {
          return x.inspect();
        }) : void 0,
        variables: this.variables.map(function(x) {
          return x.inspect();
        })
      };
    };

    return Mixin;

  })(require('../entity'));

}).call(this);
