// Generated by CoffeeScript 1.6.3
(function() {
  var Codo, FS, Path, Winston, walkdir;

  FS = require('fs');

  Path = require('path');

  walkdir = require('walkdir');

  Winston = require('winston');

  module.exports = Codo = {
    Environment: require('./environment'),
    Tools: {
      Markdown: require('./tools/markdown'),
      Referencer: require('./tools/referencer')
    },
    Entities: {
      File: require('./entities/file'),
      Class: require('./entities/class'),
      Method: require('./entities/method'),
      Variable: require('./entities/variable'),
      Property: require('./entities/property'),
      Mixin: require('./entities/mixin'),
      Extra: require('./entities/extra')
    },
    Meta: {
      Method: require('./meta/method'),
      Parameter: require('./meta/parameter')
    },
    version: function() {
      return JSON.parse(FS.readFileSync(Path.join(__dirname, '..', 'package.json'), 'utf-8'))['version'];
    },
    parseProject: function(path, options) {
      var environment, extra, filename, input, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      options.name || (options.name = this.detectName(path));
      options.readme || (options.readme = this.detectReadme(path));
      options.basedir || (options.basedir = path);
      environment = new this.Environment(options);
      if (environment.options.readme) {
        environment.readExtra(Path.join(path, environment.options.readme));
      }
      _ref = options.extras || this.detectExtras(path);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        extra = _ref[_i];
        environment.readExtra(Path.join(path, extra));
      }
      _ref1 = options.inputs || [path];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        input = _ref1[_j];
        if (FS.existsSync(input)) {
          if (FS.lstatSync(input).isDirectory()) {
            _ref2 = walkdir.sync(input);
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              filename = _ref2[_k];
              if (filename.match(/\._?coffee$/)) {
                environment.readCoffee(filename);
              }
            }
          } else {
            environment.readCoffee(Path.resolve(input));
          }
        } else {
          Winston.warn("" + input + " (" + (Path.join(process.cwd(), input)) + ") skipped â€“ does not exist");
        }
      }
      environment.linkify();
      return environment;
    },
    detectDefaults: function(path) {
      var bool, config, configs, error, option, results, _i, _len, _ref;
      results = {
        _: []
      };
      try {
        if (FS.existsSync(Path.join(path, '.codoopts'))) {
          configs = FS.readFileSync(Path.join(path, '.codoopts'), 'utf8');
          _ref = configs.split('\n');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            config = _ref[_i];
            if (option = /^-{1,2}([\w-]+)\s+(['"])?(.*?)\2?$/.exec(config)) {
              results[option[1]] = option[3];
            } else if (bool = /^-{1,2}([\w-]+)\s*$/.exec(config)) {
              results[bool[1]] = true;
            } else if (config !== '') {
              results._.push(config);
            }
          }
        }
        return results;
      } catch (_error) {
        error = _error;
        if (!this.quiet) {
          return Winston.error("Cannot parse .codoopts file: " + error.message);
        }
      }
    },
    detectName: function(path) {
      var config, name, _ref;
      if (FS.existsSync(Path.join(path, 'package.json'))) {
        name = JSON.parse(FS.readFileSync(Path.join(path, 'package.json'), 'utf-8'))['name'];
      }
      if (!name && FS.existsSync(Path.join(path, '.git', 'config'))) {
        config = FS.readFileSync(Path.join(path, '.git', 'config'), 'utf-8');
        name = (_ref = /github\.com[:/][^/]+\/(.*)\.git/.exec(config)) != null ? _ref[1] : void 0;
      }
      if (!name) {
        name = Path.basename(path);
      }
      return name.charAt(0).toUpperCase() + name.slice(1);
    },
    detectReadme: function(path) {
      var attempt, attempts, _i, _len;
      attempts = ['README.markdown', 'README.md', 'README'];
      for (_i = 0, _len = attempts.length; _i < _len; _i++) {
        attempt = attempts[_i];
        if (FS.existsSync(Path.join(path, attempt))) {
          return attempt;
        }
      }
    },
    detectExtras: function(path) {
      return ['CHANGELOG', 'CHANGELOG.markdown', 'CHANGELOG.md', 'AUTHORS', 'AUTHORS.md', 'AUTHORS.markdown', 'LICENSE', 'LICENSE.md', 'LICENSE.markdown', 'LICENSE.MIT', 'LICENSE.GPL', 'README.markdown', 'README.md', 'README'].filter(function(attempt) {
        return FS.existsSync(Path.join(path, attempt));
      });
    }
  };

}).call(this);
