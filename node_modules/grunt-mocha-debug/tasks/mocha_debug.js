// Generated by CoffeeScript 1.7.1
(function() {
  var EventEmitter, Stream, cs, data, express, fs, generateHtml, mocha, mochaBin, mochaBridge, mochaCss, mochaJs, mochaRoot, nodeTest, page, path, phantomjs, phantomjsWrapper, pluginRoot, preparePhantomTest, reporter, reporterMap, runnerJs, server, setupPhantomJS, setupServer, spawn, taskDone, testHtml;

  spawn = require('child_process').spawn;

  Stream = require('stream');

  express = require('express');

  cs = require('coffee-script');

  path = require('path');

  fs = require('fs');

  phantomjsWrapper = require('phantomjs-wrapper');

  mocha = require('mocha');

  EventEmitter = require('events').EventEmitter;

  reporterMap = require('./lib/reporters');

  data = {
    debug: {},
    child: null
  };

  pluginRoot = __dirname;

  while (!fs.existsSync(path.join(pluginRoot, 'package.json'))) {
    pluginRoot = path.dirname(pluginRoot);
  }

  pluginRoot = path.relative(process.cwd(), pluginRoot);

  mochaRoot = path.join(pluginRoot, 'node_modules', 'mocha');

  mochaCss = path.join(mochaRoot, 'mocha.css');

  mochaJs = path.join(mochaRoot, 'mocha.js');

  mochaBin = path.join(mochaRoot, 'bin', 'mocha');

  runnerJs = fs.readFileSync(path.join(path.dirname(__dirname), 'node_modules', 'run-mocha', 'index.js'), 'utf8');

  taskDone = testHtml = server = phantomjs = page = reporter = null;

  setupServer = function(grunt, options, done) {
    var address, app, port;
    app = express();
    app.get(options.testUrl, (function(_this) {
      return function(req, res) {
        return res.send(testHtml);
      };
    })(this));
    app.use(express["static"](process.cwd()));
    port = options.listenPort, address = options.listenAddress;
    return server = app.listen(port, address, (function(_this) {
      return function() {
        port = port || server.address().port;
        grunt.log.ok("Serving tests on http://" + address + ":" + port);
        return setupPhantomJS.call(_this, grunt, options, done);
      };
    })(this));
  };

  setupPhantomJS = function(grunt, options, done) {
    return phantomjsWrapper({
      timeout: options.phantomTimeout
    }, (function(_this) {
      return function(err, phantom) {
        phantomjs = phantom;
        grunt.log.ok('PhantomJS started');
        phantomjs.on('closed', function() {
          page.close();
          grunt.log.writeln();
          grunt.log.ok('PhantomJS closed');
          return phantomjs = null;
        });
        return phantomjs.createPage(function(err, webpage) {
          var address, failed, port, suiteStack, url, _ref;
          suiteStack = null;
          failed = false;
          page = webpage;
          if (options.displayConsole) {
            page.on('consoleMessage', function(msg) {
              return grunt.log.ok("PhantomJS console: " + msg);
            });
          }
          if (options.displayAlerts) {
            page.on('alert', function(msg) {
              return grunt.log.ok("PhantomJS alert: " + msg);
            });
          }
          page.on('callback', function(event) {
            return reporter.send(event);
          });
          page.on('error', function(err) {
            grunt.log.error("PhantomJS error: " + err.message);
            return taskDone(false);
          });
          page.on('resourceError', function(err) {
            grunt.log.error("PhantomJS error: failed to load " + err.url);
            return taskDone(false);
          });
          url = options.testUrl;
          _ref = server.address(), address = _ref.address, port = _ref.port;
          return page.open("http://" + address + ":" + port + url, function() {});
        });
      };
    })(this));
  };

  preparePhantomTest = function(grunt, options, done) {
    var args, modulePath, opts;
    taskDone = done;
    testHtml = generateHtml.call(this, options);
    modulePath = path.join(__dirname, 'lib', 'reporter.js');
    args = [modulePath, options.reporter];
    opts = {
      stdio: [0, options.reporterOutput, 2, 'ipc']
    };
    reporter = spawn(process.execPath, args, opts);
    return reporter.on('close', (function(_this) {
      return function(code) {
        if (options.reporterOutput !== 1) {
          fs.closeSync(options.reporterOutput);
        }
        return done(code === 0);
      };
    })(this));
  };

  nodeTest = function(grunt, options, done) {
    var check, checkDebug, files, startMocha;
    files = options.files;
    check = this.options().check;
    if (check) {
      check = grunt.file.expand(check);
    } else {
      check = files;
    }
    checkDebug = (function(_this) {
      return function() {
        var code, file, _i, _len;
        for (_i = 0, _len = check.length; _i < _len; _i++) {
          file = check[_i];
          code = grunt.file.read(file);
          if (/^\s*debugger/gm.test(code)) {
            data.debug[file] = true;
          } else {
            delete data.debug[file];
          }
        }
        return startMocha();
      };
    })(this);
    startMocha = (function(_this) {
      return function() {
        var args, dir, opts;
        dir = path.dirname(__dirname);
        files.unshift(path.join(dir, 'node_modules', 'run-mocha', 'index.js'));
        args = ['--ui', options.ui, '--reporter', options.reporter, '--compilers', 'coffee:coffee-script'].concat(args, files);
        if (options.checkLeaks) {
          if (Array.isArray(options.globals)) {
            args.unshift(options.globals.join(','));
            args.unshift('--globals');
          }
          args.unshift('--check-leaks');
        }
        if (data.debug && Object.keys(data.debug).length) {
          args.unshift('--debug-brk');
        }
        opts = {
          stdio: [0, options.reporterOutput, 2]
        };
        data.child = spawn(mochaBin, args, opts);
        return data.child.on('close', function(code) {
          data.child = null;
          if (options.reporterOutput !== 1) {
            fs.closeSync(options.reporterOutput);
          }
          return done(code === 0);
        });
      };
    })(this);
    if (data.child) {
      data.child.on('close', checkDebug);
      return data.child.kill('SIGTERM');
    } else {
      return checkDebug();
    }
  };

  generateHtml = function(options) {
    var body, css, file, files, mochaOpts, tags, _i, _len;
    files = options.files;
    tags = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      tags.push("<script src=" + file + "></script>");
    }
    mochaOpts = {
      ui: options.ui,
      checkLeaks: options.checkLeaks,
      globals: options.globals instanceof Array ? options.globals : []
    };
    body = options.body || ("<div id=\"mocha\">\n  <script>\n  mochaOpts = " + (JSON.stringify(mochaOpts)) + ";\n  " + runnerJs + "\n  </script>\n  <script src=\"" + mochaJs + "\"></script>\n  <script>\n  " + mochaBridge + "\n  </script>\n  " + (tags.join('\n')) + "\n  <script>\n  mocha.run();\n  </script>\n</div>");
    css = "<link rel=\"stylesheet\" href=\"" + mochaCss + "\" />";
    return "<!DOCTYPE html>\n<html>\n  <head>\n    <title>test runner</title>\n    <meta charset=\"utf-8\">\n    " + css + "\n  </head>\n  <body>\n  " + body + "\n  </body>\n</html>";
  };

  mochaBridge = (function() {
    var GruntReporter, HtmlReporter, mochaInstance;
    mochaInstance = window.Mocha || window.mocha;
    HtmlReporter = mochaInstance.reporters.HTML;
    GruntReporter = function(runner) {
      var event, events, _i, _len, _results;
      events = ['test', 'test end', 'suite', 'suite end', 'fail', 'pass', 'pending', 'end'];
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        event = events[_i];
        _results.push((function(event) {
          return runner.on(event, function(obj, err) {
            var ev;
            ev = {
              err: err,
              type: event
            };
            if (obj) {
              ev.obj = {
                title: obj.title,
                fullTitle: obj.fullTitle(),
                slow: obj.slow(),
                duration: obj.duration,
                pending: obj.pending,
                state: obj.state
              };
              if (obj.fn) {
                ev.obj.fn = obj.fn.toString();
              }
              if (obj.total) {
                ev.obj.total = obj.total();
              }
            }
            return callPhantom(ev);
          });
        })(event));
      }
      return _results;
    };
    return mocha.setup({
      reporter: typeof callPhantom !== "undefined" && callPhantom !== null ? GruntReporter : HtmlReporter,
      ui: mochaOpts.ui || 'bdd',
      ignoreLeaks: !mochaOpts.checkLeaks,
      globals: mochaOpts.globals
    });
  }).toString();

  mochaBridge = "(" + mochaBridge + ")();";

  module.exports = function(grunt) {
    return grunt.registerMultiTask('mocha_debug', grunt.file.readJSON('package.json').description, function() {
      var done, options, output;
      options = this.options({
        reporter: 'dot',
        ui: 'bdd',
        checkLeaks: false,
        reporterOutput: 1,
        displayConsole: true,
        displayAlerts: true,
        phantomjs: false,
        phantomTimeout: 300000,
        listenAddress: "127.0.0.1",
        listenPort: 0,
        testUrl: '/'
      });
      if (!options.src) {
        grunt.log.error('Need to specify at least one source file');
        return false;
      }
      if (!(options.reporter in reporterMap) || !reporterMap[options.reporter]) {
        grunt.log.error("Invalid reporter '" + options.reporter + "'");
        return false;
      }
      output = options.reporterOutput;
      if (output !== 1) {
        if (typeof output === 'string') {
          options.reporterOutput = fs.openSync(output, 'w+');
        } else {
          grunt.log.error("Invalid reporter output");
          return false;
        }
      }
      done = this.async();
      options.files = grunt.file.expand(options.src);
      if (options.phantomjs) {
        preparePhantomTest.call(this, grunt, options, done);
        if (!server) {
          return setupServer.call(this, grunt, options, done);
        } else if (!phantomjs || phantomjs.closed) {
          return setupPhantomJS.call(this, grunt, options, done);
        } else {
          return page.reload();
        }
      } else {
        return nodeTest.call(this, grunt, options, done);
      }
    });
  };

}).call(this);
