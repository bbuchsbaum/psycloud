// Generated by CoffeeScript 1.7.1
(function() {
  var Page, debug, lastActivity, listenPort, options, pages, port, randomPort, read, requestCb, send, server, shared, system, timeout, webpage, webserver,
    __slice = [].slice;

  system = require('system');

  webpage = require('webpage');

  webserver = require('webserver');

  shared = require('../src/shared');

  lastActivity = new Date().valueOf();

  randomPort = function() {
    var end, rv, start;
    start = 49152;
    end = 65535;
    rv = start + Math.random() * (end - start);
    return Math.round(rv);
  };

  pages = [];

  Page = (function() {
    var asyncMethods, method, methods, _i, _j, _len, _len1, _ref, _ref1;

    methods = {};

    _ref = shared.methods;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      method = _ref[_i];
      methods[method] = true;
    }

    asyncMethods = {};

    _ref1 = shared.asyncMethods;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      method = _ref1[_j];
      asyncMethods[method] = true;
    }

    function Page(cb) {
      var event, _fn, _k, _len2, _ref2;
      this.id = pages.length;
      this.page = webpage.create();
      pages.push(this);
      _ref2 = shared.events;
      _fn = (function(_this) {
        return function(event) {
          return _this.page[event] = function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return send({
              type: 'pageEvent',
              pageId: _this.id,
              event: event,
              args: args
            });
          };
        };
      })(this);
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        event = _ref2[_k];
        _fn(event);
      }
      cb({
        type: 'pageCreate',
        pageId: this.id
      });
    }

    Page.prototype.getProperty = function(name, cb) {
      var val;
      val = this.page[name];
      return cb({
        args: [null, val]
      });
    };

    Page.prototype.setProperty = function(name, val, cb) {
      var e, msg;
      try {
        this.page[name] = val;
        msg = {
          args: [null]
        };
      } catch (_error) {
        e = _error;
        msg = {
          args: [e.message]
        };
      }
      return cb(msg);
    };

    Page.prototype.callMethod = function(name, args, cb) {
      var callback, e, rv;
      callback = (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (args[0] instanceof Error) {
            args[0] = args[0].message;
          }
          if (args[0] === 'success') {
            args[0] = void 0;
          }
          return cb({
            type: 'pageMethodCallback',
            args: args
          });
        };
      })(this);
      if (name in methods) {
        try {
          rv = this.page[name].apply(this.page, args);
          return callback(null, rv);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      } else if (name in asyncMethods) {
        args.push(callback);
        return this.page[name].apply(this.page, args);
      }
    };

    Page.prototype.send = function(message, cb) {
      switch (message.pageMessageType) {
        case 'callMethod':
          return this.callMethod(message.name, message.args, cb);
        case 'getProperty':
          return this.getProperty(message.name, cb);
        case 'setProperty':
          return this.setProperty(message.name, message.val, cb);
      }
    };

    return Page;

  })();

  send = function(message) {
    lastActivity = new Date().valueOf();
    message = JSON.stringify(message);
    if (debug) {
      console.log("Sending: " + message);
    }
    return system.stderr.write(message + '\n');
  };

  read = function(reportError) {
    var e, message;
    message = system.stdin.readLine();
    try {
      return JSON.parse(message);
    } catch (_error) {
      e = _error;
      if (reportError) {
        console.log("" + e.message + "(" + message + ")");
        return phantom.exit();
      }
    }
  };

  options = read(false);

  if (typeof (options != null ? options.timeout : void 0) !== 'number' || options.timeout <= 0) {
    timeout = 5000;
    debug = false;
  } else {
    timeout = options.timeout;
    debug = options.debug;
  }

  setInterval(function() {
    if (new Date().valueOf() - lastActivity > timeout) {
      send({
        type: 'phantomTimeout'
      });
      if (debug) {
        console.log("Exiting PhantomJS due to inactivity(" + timeout + " ms)");
      }
      return phantom.exit();
    }
  }, 1000);

  listenPort = system.args[1];

  server = webserver.create();

  requestCb = function(req, res) {
    var cb, msg;
    cb = function(msg) {
      var body;
      body = JSON.stringify(msg);
      res.statusCode = 200;
      res.setHeader('Content-Type', 'application/json');
      res.write(body);
      return res.close();
    };
    if (debug) {
      console.log("Receiving: " + req.post);
    }
    msg = JSON.parse(req.post);
    lastActivity = new Date().valueOf();
    switch (msg.type) {
      case 'createPage':
        return new Page(cb);
      case 'pageMessage':
        return pages[msg.pageId].send(msg, cb);
    }
  };

  while (true) {
    port = randomPort();
    if (server.listen("127.0.0.1:" + port, requestCb)) {
      break;
    }
  }

  system.stderr.writeLine(port);

  if (debug) {
    console.log("PhantomJS started. Will exit after " + timeout + " ms of inactivity");
  }

}).call(this);
